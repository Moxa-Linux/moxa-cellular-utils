#!/bin/bash
#
#       Copyright (C) MOXA Inc. All rights reserved.
#       Copyright (C) 2014-2015  Lock Lin <Lock.Lin@moxa.com>
#       Copyright (C) 2015       Harry YJ Jhou <HarryYJ.Jhou@moxa.com>
#
#       This software is distributed under the terms of the
#       MOXA License.  See the file COPYING-MOXA for details.
#
#       cell_mgmt
#               cellular management. It supports sierra MC9090 MC7304 MC7354.
#
 

#--------- Initialize Global variables ---------
PKG="moxa-cellular-utils"
VERSION="1.15.1"
PID=$$
STATUS_DIR=/var/run/${PKG}

# profile
CONF_DIR=/etc/${PKG}
#CONF_DIR=/home/moxa/moxa-cellular-utils${CONF_DIR}
PROFILE_FILE=${CONF_DIR}/${PKG}.conf
PRODUCT_DIR=${CONF_DIR}/product.d
MODULE_DIR=${CONF_DIR}/module.d

KVERSION=$(which kversion)
[ -z "${KVERSION}" ] && >&2 echo "Error: \`kversion\` not found." && exit 1

PRODUCT="$(${KVERSION} 2> /dev/null | awk '{print $1}')"

# QMI
# new libqmi includes a tool called "qmi-proxy"
# use qmicli -p means interaction with the QMI interface of modem by "qmi-proxy"
QMICLI=$(which qmicli)
QMICLI_END="-p"
[ -z "${QMICLI}" ] && >&2 echo "Error: \`qmicli\` not found." && exit 1

# variables
FORCE=0


_exit() {
	if [ ${FORCE} -eq 0 ]; then
		flock -u 9 2>/dev/null
	fi
	exit $1
}

_func_exist() {
	if type ${1} 2> /dev/null | grep -q 'function' 2>/dev/null; then
		return 0
	fi
	return 1
}

_get_op_func() {
	local op="$1"

	if _func_exist _module_${MODULE_ID}_${op}; then
		echo _module_${MODULE_ID}_${op}
	elif [ x"${QMI_PORT}" != x"NotSupport" ] && _func_exist qmi_${op}; then
		# unlock if using qmi (proxy is used)
		flock -u 9 2>/dev/null
		echo qmi_${op}
	elif [ x"${AT_PORT}" != x"NotSupport" ] && _func_exist at_${op}; then
		echo at_${op}
	else
		echo ""
	fi
}

_exec_op_rtn() {
	local func="$(_get_op_func $1)"

	if [ x"${func}" != x"" ]; then
		#echo "eval ${func} ${@:2}"
		eval ${func} ${@:2}
	else
		>&2 echo "Error: Operation not support."
		return 3
	fi
}

_exec_op() {
	local func="$(_get_op_func $1)"

	if [ x"${func}" == x"" ]; then
		>&2 echo "Error: Operation not support."
		_exit 3
	fi

	#echo "eval ${func} ${@:2}"
	eval ${func} ${@:2}
}

_save_state() {
	local KEY=$1
	local VAL=$2

	echo "Saving state... ($KEY: $VAL)"

	if [ -f $STATE_FILE ]; then
		PREVIOUS=`cat $STATE_FILE 2>/dev/null`
		PREVIOUS=`echo "$PREVIOUS" | grep -v $KEY`
		if [ "x$PREVIOUS" != "x" ]; then
			echo $PREVIOUS > $STATE_FILE
		else
			rm $STATE_FILE
		fi
	fi

	if [ "x$VAL" != "x" ]; then
		echo "$KEY=\"$VAL\"" >> $STATE_FILE
	fi
}

_load_state() {
	if [ -f $STATE_FILE ]; then
		# Loading previous state
		. $STATE_FILE
	fi
}

_clear_state() {
	echo "Clearing state..."
	rm -f $STATE_FILE
}


_load_profile() {
	. $PROFILE_FILE
	for conf in $(ls ${PRODUCT_DIR}); do
		if [ "${conf: -5}" == ".conf" ]; then
			. ${PRODUCT_DIR}/$conf
		fi
	done
	for conf in $(ls ${MODULE_DIR}); do
		if [ "${conf: -5}" == ".conf" ]; then
			. ${MODULE_DIR}/$conf
		fi
	done

	eval "_product_${PRODUCT}_profile" 2>/dev/null
	if [ x"$?" != x"0" ]; then
		>&2 echo "Error: \`kversion\` or profile not found."
		_exit 1
	fi
}

_search_wwan_node() {
	local module_name
	local vendor_id
	local product_id
	local slot_num=0
	local id=-1

	for i in ${MODULE_PATH[@]}; do
		let slot_num++
		if [ ! -e $i ]; then
			continue
		fi

		vendor_id=$(cat $i/idVendor 2> /dev/null)
		product_id=$(cat $i/idProduct 2> /dev/null)
		module_name=$(cat $i/product 2> /dev/null)

		if ! _func_exist _module_${vendor_id}_${product_id}; then
			>&2 echo "Error: Module \"${module_name}\" not support."
			continue
		fi

		let id++
		ALL_MODULE_ID[${id}]=${vendor_id}_${product_id}
		ALL_MODULE_NAME[${id}]=${module_name}
		ALL_SLOT_NUM[${id}]=$slot_num
		ALL_INTERFACE[${id}]=""
		ALL_QMI_PROTOCOL[${id}]="802-3"
		ALL_QMI_PORT[${id}]="NotSupport"
		ALL_AT_PORT[${id}]="NotSupport"
		ALL_GPS_PORT[${id}]="NotSupport"
		ALL_MODEM_PORT[${id}]="NotSupport"
		ALL_AT_TIMEOUT[${id}]="0.3"

		eval "_module_${vendor_id}_${product_id} \
			$i ${id} \"${module_name}\"" 2>/dev/null
		if [ $? -ne 0 ]; then
			>&2 echo "Error: Initialize module \"${module_name}\" failed."
			continue
		fi
	done
}

_set_variables() {
	MODULE_ID="${ALL_MODULE_ID[$INTERFACE]}"
	SLOT="${ALL_SLOT_NUM[$INTERFACE]}"
	MODULE_NAME="${ALL_MODULE_NAME[$INTERFACE]}"	
	QMI_PROTOCOL=${ALL_QMI_PROTOCOL[${INTERFACE}]}

	QMI_NODE="${ALL_INTERFACE[$INTERFACE]}"
	if [ x"${ALL_QMI_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		QMI_PORT="NotSupport"
	else
		QMI_PORT="/dev/${ALL_QMI_PORT[$INTERFACE]}"
	fi
	if [ x"${ALL_AT_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		AT_PORT="NotSupport"
	else
		AT_PORT="/dev/${ALL_AT_PORT[$INTERFACE]}"
	fi
	if [ x"${ALL_GPS_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		GPS_PORT="NotSupport"
	else
		GPS_PORT="/dev/${ALL_GPS_PORT[$INTERFACE]}"
	fi
	if [ x"${ALL_MODEM_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		MODEM_PORT="NotSupport"
	else
		MODEM_PORT="/dev/${ALL_MODEM_PORT[$INTERFACE]}"
	fi
	AT_TIMEOUT="${ALL_AT_TIMEOUT[$INTERFACE]}"

	# state file for different interface
	if [ x"$INTERFACE" != x"" ]; then
		mkdir -p "${STATUS_DIR}"
		LOCK_FILE="${STATUS_DIR}/${INTERFACE}.lock"
		STATE_FILE="${STATUS_DIR}/${INTERFACE}.state"
		STATUS_FILE="${STATUS_DIR}/${INTERFACE}.status"
	fi

	# Load previous state, if any
	CID=""
	PDH=""
	_load_state
}

init() {
	unset ALL_MODULE_ID
	unset ALL_MODULE_NAME
	unset ALL_SLOT_NUM
	unset ALL_INTERFACE
	unset ALL_QMI_PROTOCOL
	unset ALL_QMI_PORT
	unset ALL_AT_PORT
	unset ALL_GPS_PORT
	unset ALL_MODEM_PORT
	unset ALL_AT_TIMEOUT

	if [ -f $PROFILE_FILE ]; then
		_load_profile
		_search_wwan_node
		if [ x"${INTERFACE}" == x"" ] || \
			[ ${INTERFACE} -ge ${#ALL_INTERFACE[@]} ]; then
			INTERFACE=0
		fi
		_set_variables
	else
		>&2 echo "Error: "${PROFILE_FILE}" does not exist." && \
			_exit 2
	fi
}

_connect_error_note() {
	>&2 echo "Please check the following items before start LTE connection:"
	>&2 echo "  1. Antenna setting"
	>&2 echo "  2. SIM card inserted and PIN code unlocked, \`sim_status\`"
	>&2 echo "  3. Signal strength \`signal\`"
	>&2 echo "  4. Remember to set_apn before start LTE connection"
}

_start_network_init() {
	ignore_dns_gw=0
	local card_status=""
	local interface_num="$INTERFACE"
	[ x"$interface_num" == x"0" ] && interface_num=""


	APN="$(eval echo \$APN$interface_num)"
	PIN="$(eval echo \$PIN$interface_num)" 
	Phone="$(eval echo \$Phone$interface_num)" 
	Username="$(eval echo \$Username$interface_num)"
	Password="$(eval echo \$Password$interface_num)"

	# modify APN Username Password PIN
	for args in $@; do
		for par in "APN" "Username" "Password" "PIN" "Phone"; do
			if [ $(echo $args | grep "$par=") ]; then
				eval "$par=${args##*$par=}"
				eval "sed -i s/$par$interface_num=.*/$par$interface_num=\$$par/ $PROFILE_FILE"
			fi
		done
		[ x"$args" == x"ignore-dns-gw" ] && ignore_dns_gw=1
	done

	# check APN
	if [ x"$APN" == x"" ]; then
		>&2 echo "Error: Please assign a valid APN."
		_cell_usage_cmd _cell_usage_start
		_exit 4
	fi

	card_status="$(_exec_op sim_status | grep "+CPIN")"
	if [ "$(echo "${card_status}" | grep "PIN")" ] && [ x"$PIN" == x"" ]; then
		>&2 echo "Error: Please assign the PIN code to unlock SIM card"
		_cell_usage_cmd _cell_usage_start
		_exit 4
	fi

	# Check PIN status
	_cell_unlock_pin "${PIN}" "_cell_usage_start"
}

#--------- qmi base functions -----------
_qmicli() {
	local i
	local qmi_cmd=""
	local qmi_std=""
	local qmi_err=""
	local qmi_ret=0
	local cmd=""

	qmi_cmd="$QMICLI -d $QMI_PORT $@ $QMICLI_END"
	#echo ${qmi_cmd}

	for i in {1..5}; do
		eval "$( (${qmi_cmd}) 2> \
			>(qmi_err=$(cat); typeset -p qmi_err) > \
			>(qmi_std=$(cat); typeset -p qmi_std); \
			qmi_ret=$?; typeset -p qmi_ret )"
		# error 3 (internal) and 31 (invalid service type)
		if ! (echo ${qmi_err} | grep "QMI protocol error (3)") && 
			! (echo ${qmi_err} | grep "QMI protocol error (31)"); then
			echo "${qmi_std}"
			return 0
		fi
	done

	# reset qmi service
	>&2 echo "Error: Internal error, please reset module and try again."
	_exit 1
}

_qmicli_value() {
	local output="$1"
	local key="$2"
	local num="$3"
	local num_opt=""
	local cmd=""

	if [ -z "${3}" ]; then
		num=1
	fi
	num_opt="| sed -n ${num}p"

	cmd="echo \"${output}\" | awk '/${key}:/{ print}' ${num_opt} | \
		sed \"s/^[^:]*: [']*//;s/[' \t]*$//\""
	eval "${cmd}"
}

_qmi_start_network() {
	local is_raw_ip="N"
	local raw_ip_file="/sys/class/net/${QMI_NODE}/qmi/raw_ip"

	if [ x"$CID" != x"" ]; then
		USE_PREVIOUS_CID="--client-cid=$CID"
	fi

	if [ x"$PDH" != x"" ]; then
		>&2 echo "Error: Cannot re-start network, PDH already exists."
		_exit 1
	fi

	# initialize the interface with protocol
	if [ x"${QMI_PROTOCOL}" == x"802-3" ]; then
		is_raw_ip=N
	elif [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
		is_raw_ip=Y
	else
		QMI_PROTOCOL="802-3"
		is_raw_ip=N
	fi

	if [ -f "${raw_ip_file}" ]; then
		echo ${is_raw_ip} > ${raw_ip_file} 2> /dev/null
		_qmicli --set-expected-data-format=${QMI_PROTOCOL} || \
			(>&2 echo "Error: Cannot update data format." && \
			 _exit 1)
	elif [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
		>&2 echo "Error: \"raw-ip\" not supported."
		_exit 1
	fi

	#START_NETWORK_CMD="$QMICLI -d $QMI_PORT --wds-start-network=$APN --client-no-release-cid --device-open-net=net-802-3|net-no-qos-header $QMICLI_END"
	START_NETWORK_CMD="_qmicli --wds-start-network='apn=$APN,ip-type=4' --client-no-release-cid --device-open-net=net-${QMI_PROTOCOL}|net-no-qos-header"
	echo "Starting network with '$START_NETWORK_CMD'..."

	if [ x"$QMIDEBUG" != x"" ]; then
		if [ x"$INTERFACE" == x"" -o x"$INTERFACE" == x"1" ]; then
			START_NETWORK_OUT="\
[/dev/cdc-wdm0] Network started
        Packet data handle: '3634026241'
[/dev/cdc-wdm0] Client ID not released:
        Service: 'wds'
        CID: '80'"
		else
			START_NETWORK_OUT="\
[/dev/cdc-wdm1] Network started
        Packet data handle: '363402624$3'
[/dev/cdc-wdm1] Client ID not released:
        Service: 'wds'
        CID: '80'"
		fi
	else
		START_NETWORK_OUT=`$START_NETWORK_CMD`
	fi

	# Save the new CID if we didn't use any before
	if [ x"$CID" == x"" ]; then
		CID=`echo "$START_NETWORK_OUT" | sed -n "s/.*CID.*'\(.*\)'.*/\1/p"`
		if [ x"$CID" == x"" ]; then
			>&2 echo "Error: Network start failed, client not allocated."
			_connect_error_note
			_exit 1
		else
			_save_state "CID" $CID
		fi
	fi

	PDH=`echo "$START_NETWORK_OUT" | sed -n "s/.*handle.*'\(.*\)'.*/\1/p"`
	if [ x"$PDH" == x"" ]; then
		>&2 echo "Error: Network start failed, no packet data handle."
		_connect_error_note
		# Cleanup the client
		#$QMICLI -d "$QMI_PORT" --wds-noop --client-cid="$CID" $QMICLI_END
		_qmicli --wds-noop --client-cid="$CID"
		_clear_state
		_exit 1
	else
		_save_state "PDH" $PDH
	fi

	echo "Network started successfully"
}

_qmi_stop_network() {
	if [ x"$CID" == x"" ]; then
		echo "Network already stopped"
	elif [ x"$PDH" == x"" ]; then
		echo "Network already stopped; need to cleanup CID $CID"
		# Cleanup the client
		#$QMICLI -d "$QMI_PORT" --wds-noop --client-cid="$CID" $QMICLI_END
		_qmicli --wds-noop --client-cid="$CID"
		PDH=""
	else
		#STOP_NETWORK_CMD="$QMICLI -d $QMI_PORT --wds-stop-network=$PDH --client-cid=$CID $QMICLI_END"
		STOP_NETWORK_CMD="_qmicli --wds-stop-network=$PDH --client-cid=$CID"
		echo "Stopping network with '$STOP_NETWORK_CMD'..."

		if [ x"$QMIDEBUG" != x"" ]; then
			STOP_NETWORK_OUT="\
[/dev/cdc-wdm$INTERFACE] Network stopped
"
		else
			STOP_NETWORK_OUT=`$STOP_NETWORK_CMD`
		fi
		PDH=""
		CID=""

		echo "Network stopped successfully"
	fi

	_clear_state
}

_qmi_packet_service_status() {
	if [ x"$CID" != x"" ]; then
		USE_PREVIOUS_CID="--client-cid=$CID --client-no-release-cid"
	fi

	#STATUS_CMD="$QMICLI -d $QMI_PORT --wds-get-packet-service-status $USE_PREVIOUS_CID $QMICLI_END"
	STATUS_CMD="_qmicli --wds-get-packet-service-status $USE_PREVIOUS_CID"
	echo "Getting status with '$STATUS_CMD'..."

	if [ x"$QMIDEBUG" != x"" ]; then
		CONN="disconnected"
	else
		CONN="$(_qmicli_value "$(${STATUS_CMD})" "Connection status")"
	fi

	if [ x"$CONN" == x"" ]; then
		>&2 echo "Error: Couldn't get packet service status."
		_exit 1
	else
		echo "Status: $CONN"
		if [ x"$CONN" != x"connected" ]; then
			_exit 1
		fi
	fi
}

_qmi_kill_proxy() {
	local proxy_pid=`ps wwax | grep -v "grep" | grep "qmi-proxy" | awk '{print $1}'`
	if [ ! -z "${proxy_pid}" ]; then
		kill ${proxy_pid}
	fi
}

_qmi_card_app_state() {
	local app_state="$(_qmicli_value "${1}" "Application state")"

	case "${app_state}" in
		"pin1-or-upin-pin-required")
			echo "+CPIN: SIM PIN"
			;;
		"puk1-or-upin-puk-required")
			echo "+CPIN: SIM PUK"
			;;
		"ready")
			echo "+CPIN: READY"
			;;
		*)
			echo "+CME ERROR: SIM ${app_state}"
			return 1
			;;
	esac
}

_qmi_card_status() {
	local card_info="$(_qmicli --uim-get-card-status)"
	local card_state="$(_qmicli_value "${card_info}" "Card state")"

	case "${card_state}" in
		"absent")
			echo "+CME ERROR: SIM not inserted"
			;;
		"present")
			_qmi_card_app_state "${card_info}"
			;;
		*)
			echo "+CME ERROR: SIM ${card_state}"
			return 1
			;;
	esac
}

#--------- qmi functions -----------

qmi_attach_status() {
	local info="$(_qmicli --nas-get-serving-system)"
	local cs=$(_qmicli_value "${info}" "CS")
	local ps=$(_qmicli_value "${info}" "PS")

	echo "CS: ${cs}"
	echo "PS: ${ps}"
}

#check cellular status
qmi_status() {
	local con_status=$(_qmi_packet_service_status | grep "Status")


	echo ${con_status}
	if [ x"$(echo ${con_status}| awk '{print $2}')" == x"connected" ]; then
		_exit 0
	else
		_exit 1
	fi
}

#cellular signal strength in dbm
qmi_signal() {
	local signal 


	#signal=`$QMICLI -d ${QMI_PORT} --nas-get-signal-strength $QMICLI_END | tr "'" " " | grep "Network" | head -1 | awk '{print $2 " " $4}'`
	signal=`_qmicli --nas-get-signal-strength | tr "'" " " | grep "Network" | head -1 | awk '{print $2 " " $4}'`
	signal_dbm="$(echo $signal | awk '{print $2}')"
	if [ "$signal_dbm" -le "-1" 2>/dev/null ]; then
		echo "${signal} dbm"
		return 0
	else
		echo "signal out of range"
		return 1
	fi
}

# cell_signal_adv
qmi_signal_adv() {
	local csq
	local rssi
	local ecio
	local signal 
	csq=$(at_signal_csq)

	signal=$(_qmicli --nas-get-signal-strength | \
		 sed "s/'\|'://g;s/^[ \t]*Network //g")
	rssi=$(echo "${signal}" | awk '/Current:/{getline; print}')
	ecio=$(echo "${signal}" | awk '/ECIO:/{getline; print}')
	[ -z "${csq}" ] && csq=99

	echo "CSQ: ${csq}"
	echo "RSSI: ${rssi}"
	echo "EcIo: ${ecio}"
	return 0
}

# cell_start
qmi_start_network() {
	local card_status=""
	local ignore_dns_gw=0
	local pin_status


	_start_network_init $@

	_qmi_start_network
	# query IP from DHCP Server 
	ip link set ${QMI_NODE} up
	if [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
		cell_udhcpc ${QMI_NODE} $ignore_dns_gw
	else
		cell_dhclient ${QMI_NODE} $ignore_dns_gw
	fi

	_exit 0
}

# cell_stop
qmi_stop_network() {
	# release IP by dhclient -r
	if [ x"${QMI_NODE}" != x"" ]; then
		if [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
			cat /var/run/udhcpc-${QMI_NODE}.pid 2> /dev/null| \
				xargs --no-run-if-empty kill
		else
			dhclient -r -pf /var/run/dhclient-${QMI_NODE}.pid \
				${QMI_NODE}
		fi
	fi
	# cellular stop by qmi-network
	_qmi_stop_network
}

qmi_sim_status() {
	_qmi_card_status
}

# unlock pin code
qmi_unlock_pin() {
	ret=$(_qmicli --uim-verify-pin=PIN1,$1)
	if ! echo "${ret}" | grep -q 'PIN verified successfully'; then
		echo $ret
		_exit 1
	fi
}

qmi_pin_retries() {
	# [/dev/cdc-wdm0] PIN status retrieved successfully
	# [/dev/cdc-wdm0] PIN1:
	#	Status: enabled-verified
	#	Verify: 3
	#	Unblock: 10
	# [/dev/cdc-wdm0] PIN2:
	#	Status: blocked
	#	Verify: 0
	#	Unblock: 10

	local pin_info="$(_qmicli --dms-uim-get-pin-status)"
	local pin_status="$(_qmicli_value "${pin_info}" "Status" 1)"
	local pin_retries="$(_qmicli_value "${pin_info}" "Verify" 1)"

	case "${pin_status}" in
		"enabled-verified"|"enabled-not-verified")
			echo ${pin_retries}
			;;
		*)
			echo 0
			;;
	esac
}

# sim card pin code protection
qmi_pin_protection(){
	local pin_num="$1"
	local pin_enable="$2"
	local pin_current="$3"
	local par_fail="0"		


	# user does not give current pin
	[ $# -ne 3 ] && par_fail="1"
	[ x"$pin_num" != x"PIN1" ] && [ x$pin_num != x"PIN2" ] && par_fail="1"
	[ x"$pin_enable" != x"enable" ] && [ x"$pin_enable" != x"disable" ] && par_fail="1"

	if [ x"$par_fail" == x"1" ]; then
		_cell_usage_cmd _cell_usage_pin_protection
		_exit 4
	else
		_qmicli --uim-set-pin-protection=$pin_num,$pin_enable,$pin_current
		_exit 0
	fi

}

qmi_set_flight_mode() {
	local flight=${1:-1}
	local mode=""

	# flight mode (persistent-low-power)
	# online mode (online)
	if [ ${flight} -eq 1 ]; then
		mode="low-power"
	else
		mode="online"
	fi
	if _qmicli --dms-set-operating-mode="${mode}" &> /dev/null; then
		return 0
	fi
	return 1
}

qmi_get_profiles() {
	_qmicli --wds-get-profile-list=3gpp | \
		awk -f ${CONF_DIR}/qmicli-profile-scan.awk
}

qmi_module_ids() {
	local info="$(_qmicli --dms-get-ids)"
	local imei=$(_qmicli_value "${info}" "IMEI")
	local esn=$(_qmicli_value "${info}" "ESN")

	echo IMEI: $imei
	echo ESN: $esn
}

qmi_iccid() {
	local iccid=$(_qmicli_value "$(_qmicli --dms-uim-get-iccid)" "ICCID")
	echo ICC-ID: $iccid
}

qmi_location_info() {
	local info=""
	local service=""
	local lac=""
	local tac=""
	local cellid=""
	local bid=""
	local nid=""
	local lcid=""


	info="$(_qmicli --nas-get-cell-location-info)"
	service="$(echo "${info}" | sed -n 2p | sed 's/[\t ]Info//g')"
	if [[ ${service} == CDMA* ]]; then
		bid=$(_qmicli_value "${info}" "Base Station ID")
		nid=$(_qmicli_value "${info}" "Network ID")
	elif [ x"${service}" == x"Intrafrequency LTE" ]; then
		cellid=$(_qmicli_value "${info}" "Global Cell ID")
		tac=$(_qmicli_value "${info}" "Tracking Area Code")
	else
		cellid=$(_qmicli_value "${info}" "Cell ID")
		lac=$(_qmicli_value "${info}" "Location Area Code")
		lcid=$(_qmicli_value "${info}" "${service} Cell ID")
	fi

	# for UMTS
	if [ x"$lac" != x"" ]; then
		echo LAC: $lac
	fi
	# for LTE
	if [ x"$tac" != x"" ]; then
		echo TAC: $tac
	fi
	# for CDMA
	if [ x"$nid" != x"" ]; then
		echo NID: $nid
	fi

	# for UMTS & LTE
	if [ x"$cellid" != x"" ]; then
		echo CellID: $cellid
	fi
	# for CDMA
	if [ x"$bid" != x"" ]; then
		echo BID: $bid
	fi

	if [ x"$lcid" != x"" ]; then
		echo LCID: $lcid
	fi
}

#--------- at functions -----------

# AT command 
cell_at_cmd() {
	local at_port=""
	local cmd="$1"
	local timeout="$2"
	local ret=""


	if [ x"$cmd" == x"" ]; then
		echo "command is null."
		return
	fi

	if [ x"${AT_PORT}" == x"NotSupport" ]; then
		if [ x"${MODEM_PORT}" == x"NotSupport" ]; then
			>&2 echo "Error: AT port and modem port not available."
			return 3
		fi
		at_port=${MODEM_PORT}
	else
		at_port=${AT_PORT}
	fi

	if [ x"$timeout" == x"" ]; then
		timeout="${AT_TIMEOUT}"
	fi

	#stty -F ${at_port} -echo raw
	#echo -n -e "ATE0\r\n" > ${at_port}
	#timeout 0.3 cat ${at_port} >/dev/null
	ls -l ${at_port} &> /dev/null
	if [ $? -ne 0 ]; then
		>&2 echo "Error: AT/Modem port (${at_port}) not ready."
		return 3
	fi
	echo -n -e "$cmd\r\n" > ${at_port}
	ret=$(timeout $timeout cat ${at_port} | tr -d '\r')
	echo "${ret}"
	if echo "${ret}" | grep -q "OK"; then
		return 0
	fi
	return 1
}

at_signal_csq() {
	local signal

	signal=$(cell_at_cmd 'AT+CSQ')
	if $(echo "${signal}" | grep -q "ERROR"); then
		echo "99"
		_exit 1
	fi
	signal=$(echo "${signal}" | grep "^+CSQ:" | awk '{print $2}' | cut -d',' -f1)
	echo ${signal}
}

at_signal() {
	local signal=""
	local service="umts"

	signal=$(cell_at_cmd 'AT+CSQ\r\n' | awk '{print $2}')
	signal=${signal##*AT}
	signal=${signal%%,*}

	service=$(_exec_op_rtn service | grep "Service:" | \
		cut -d ' ' -f 2- | awk '{print tolower($0)}')
	if [ x"$signal" != x"" ]; then
		if [ "$signal" -le "30" 2>/dev/null ] && [ "$signal" -ge "2" 2>/dev/null ] ; then
			let signal=signal-2
			let signal=signal*2-109
			echo "${service} $signal dbm"	
		else
			echo "signal out of range"
		fi
	else
		echo "signal out of range"
	fi
}

at_sim_status() {
	cell_at_cmd 'AT+CPIN?' | grep '^+CPIN:'
}

# unlock pin code
at_unlock_pin() {
	ret=$(cell_at_cmd "AT+CPIN=$1" 1 | grep 'ERROR')
	if [ x"$ret" != x"" ]; then
		echo $ret
		_exit 1
	fi
}

at_set_flight_mode() {
	local flight=${1:-1}
	local mode=""

	# flight mode (persistent-low-power)
	# online mode (online)
	if [ ${flight} -eq 1 ]; then
		mode=4
	else
		mode=1
	fi
	if cell_at_cmd "AT+CFUN=${mode}" 1 | grep -q "OK"; then
		return 0
	fi
	return 1
}

# get profile list
at_get_profiles() {
	cell_at_cmd 'AT+CGDCONT?' | grep "^+CGDCONT:" | cut -d' ' -s -f 2 | \
		awk -F"," '{print $1","$3","$2}' | sed -e 's/\"//g'
}

at_set_profile() {
	local id="$1"
	local apn="$2"
	local type="${3}"


	if [ -z "${apn}" ]; then
		data="${id}"
	else
		data="${id},\"${type}\",\"${apn}\""
	fi
	cell_at_cmd "AT+CGDCONT=${data}" 1 > /dev/null || return 1
}

# +CNUM: "ABC","12345678901",129
# OK
at_number() {
	number=$(cell_at_cmd 'AT+CNUM' | grep "^+CNUM:" | head -1 | sed 's/"//g')
	if [ ! -z "${number}" ]; then
		echo $(echo "${number}" | cut -d ',' -f 2)
	else
		echo "No number."
	fi
}

# telecommunication operator
at_operator() {
	local result
	result=$(cell_at_cmd 'AT+COPS?' | grep "^+COPS:" | \
		cut -d ' ' -f 2- | cut -s -d ',' -f 3 | sed 's/\"//g')
	if [ ! -z "${result}" ]; then
		echo $result
	else
		echo "Unknown"
	fi
}

at_location_info() {
	local ret=
	local lac=""
	local cellid=""

	cell_at_cmd 'AT+CREG=2' > /dev/null
	ret=$(cell_at_cmd 'AT+CREG?' | grep '^+CREG:' )
	[ "${#ret}" -lt "11" ] && ret=""
	if [ x"$ret" != x"" ]; then
		lac=${ret#*\"}
		lac=${lac%%\"*}
		cellid=${ret%\"*}
		cellid=${cellid##*\"}
	fi

	if [ x"$lac" != x"" ]; then
		echo LAC: $lac
	fi
	if [ x"$cellid" != x"" ]; then
		echo CellID: $cellid
	fi
}

at_module_ids() {
	local info="$(cell_at_cmd 'ATI')"
	local imei=$(echo "${info}" | grep "^IMEI:" | awk '{print $2}')
	local esn=$(echo "${info}" | grep "^ESN:" | awk '{print $2}')

	echo IMEI: $imei
	echo ESN: $esn
}

at_wvdial_template_file() {
	echo ${CONF_DIR}/wvdial/wvdial.conf.template
}

at_ppp_template_file() {
	echo ${CONF_DIR}/ppp/peers/wvdial.template
}

# Using wvdial & ppp as default
at_start_network() {
	local ignore_dns_gw=0

	local isp_name=wvdial-${INTERFACE}
	local wvdial_temp=$(_exec_op_rtn wvdial_template_file)
	local wvdial_conf=$(cat ${wvdial_temp})
	local wvdial_path=${CONF_DIR}/wvdial/wvdial-${INTERFACE}.conf
	local ppp_temp=$(_exec_op_rtn ppp_template_file)
	local ppp_conf=$(cat ${ppp_temp})
	local ppp_path=/etc/ppp/peers/${isp_name}
	local modem_port=


	_start_network_init $@

	wvdial_conf=$(echo "${wvdial_conf}" | sed -e "s|@apn@|${APN}|g")
	if [ x"${MODEM_PORT}" == x"NotSupport" ]; then
		if [ x"${AT_PORT}" == x"NotSupport" ]; then
			>&2 echo "Error: AT port and modem port not available."
			return 3
		fi
		modem_port=${AT_PORT}
	else
		modem_port=${MODEM_PORT}
	fi
	wvdial_conf=$(echo "${wvdial_conf}" | sed -e "s|@modem_port@|${modem_port}|g")
	if [ x"${Phone}" == x"" ]; then
		Phone="*99#"
	fi
	wvdial_conf=$(echo "${wvdial_conf}" | sed -e "s|@phone@|${Phone}|g")
	echo "${wvdial_conf}" > ${wvdial_path}

	ppp_conf=$(echo "${ppp_conf}" | sed -e "s|@wvdial_conf@|${wvdial_path}|g")
	ppp_conf=$(echo "${ppp_conf}" | sed -e "s|@name@|${INTERFACE}|g")

	# ignore-dns-gw
	local route=defaultroute
	local dns=

	if [ x"$ignore_dns_gw" == x"1" ];   then
		route=nodefaultroute
		dns=nodns
	fi
	# defaultroute | nodefaultroute
	ppp_conf=$(echo "${ppp_conf}" | sed -e "s|@defaultroute@|${route}|g")
	# nodns or ""
	ppp_conf=$(echo "${ppp_conf}" | sed -e "s|@nodns@|${dns}|g")
	# name
	ppp_conf=$(echo "${ppp_conf}" | sed -e "s|@name@|${INTERFACE}|g")
	ppp_conf=$(echo "${ppp_conf}" | sed -e "s|@modem_port@|${modem_port}|g")
	echo "${ppp_conf}" > ${ppp_path}

	pon ${isp_name}
	echo "Status: connecting" > "${STATUS_FILE}"
	_save_state "PPP_ISP_NAME" ${isp_name}
}

at_stop_network() {
	poff ${PPP_ISP_NAME}
	_clear_state
}

at_attach_status() {
	local info="$(cell_at_cmd "AT^SYSINFO")"
	local status="0"
	local service="0"
	local cs="detached"
	local ps="detached"


	if ! echo "${info}" | grep -q "OK"; then
		return 1
	fi
	info=$(echo "${info}" | grep "^\^SYSINFO:" | awk '{print $2}')
	status=$(echo "${info}" | cut -d ',' -f 1)
	service=$(echo "${info}" | cut -d ',' -f 2)
	if [ "${status}" == "2" ]; then
		if [ "${service}" == "1" ]; then
			cs="attached"
		elif [ "${service}" == "2" ]; then
			ps="attached"
		elif [ "${service}" == "3" ]; then
			cs="attached"
			ps="attached"
		fi
	fi
	echo "CS: ${cs}"
	echo "PS: ${ps}"
}

at_status() {
	if [ -f "${STATUS_FILE}" ]; then
		cat "${STATUS_FILE}"
	else
		echo "Status: disconnected"
	fi
}

#--------- generic functions -----------

_cell_initialize() {
	module_id="${ALL_MODULE_ID[$1]}"
	if _func_exist _module_${module_id}_initialize; then
		_module_${module_id}_initialize
	fi
}

cell_initialize() {
	if [ "$1" == "all" ]; then
		for (( i=0 ; i<${#ALL_INTERFACE[@]} ; i++ )); do
			_cell_initialize $i
		done
	else
		_cell_initialize ${INTERFACE}
	fi
}

# cellular power on by GPIO
cell_power_on() {
	local vendor_id=""
	local product_id=""
	local module_id=""
	local power_on_funcs="$(echo "$POWER_ON_FUN" | sed -e "s/\$SLOT/$SLOT/g")"

	IFS=$'\n'
	for i in $power_on_funcs ;
	do
		eval "$i"
	done

	while ((1))
	do
		product_id=$(cat ${MODULE_PATH[$((SLOT-1))]}/idProduct \
			 2> /dev/null)
		if [ x"${product_id}" != x"" ]; then
			vendor_id=$(cat ${MODULE_PATH[$((SLOT-1))]}/idVendor \
				2> /dev/null)

			# initialize after power_on
			module_id=${vendor_id}_${product_id}
			if _func_exist _module_${module_id}_initialize; then
				_module_${module_id}_initialize
			fi
			break;
		fi

		sleep 1
	done
}

# cellular power off by GPIO
cell_power_off() {
	_exec_op_rtn stop_network 2> /dev/null
	_qmi_kill_proxy
	

	power_off_funcs="$(echo "$POWER_OFF_FUN" | sed -e "s/\$SLOT/$SLOT/g")"

	IFS=$'\n'
	for i in $power_off_funcs; do
		eval "$i"
	done

	while ((1)); do
		product_id=$(cat ${MODULE_PATH[$((SLOT-1))]}/idProduct \
			 2> /dev/null)
		if [ x"${product_id}" == x"" ]; then
			break;
		fi

		sleep 1
	done
}

#cellular power off and on by GPIO
cell_power_cycle() {
	cell_power_off
	sleep 1
	cell_power_on
}

cell_switch_sim() {
	local sim_slot=$1


	if [ -z "$SWITCH_SIM_FUNC" ]; then
		>&2 echo "Error: Operation not support."
		_exit 3
	fi

	_exec_op_rtn stop_network &> /dev/null
	_qmi_kill_proxy &> /dev/null

	switch_sim_funcs="$(echo "$SWITCH_SIM_FUNC" | \
		sed -e "s/\$SLOT/$SLOT/g" | sed -e "s/\$SIM_SLOT/$sim_slot/g")"

	IFS=$'\n'
	for i in $switch_sim_funcs; do
		eval "$i"
	done
	cell_power_cycle
}

cell_set_profile() {
	local id="$1"
	local apn="$2"
	local type="${3:-IPV4V6}"


	if [ $# -lt 1 ]; then
		_cell_usage_cmd _cell_usage_set_profile
		_exit 4
	fi

	[ -z "${apn}" ] && apn="\"\""
	_exec_op_rtn set_flight_mode 1 && \
		_exec_op_rtn set_profile "${id}" "${apn}" "${type}" && \
		_exec_op_rtn set_flight_mode 0 &&
		_exit 0
	_exit 1
}

# set apn into PDP context id 1
cell_set_apn() {
	local ret
	local apn="$1"


	if [ -z "${apn}" ]; then
		_cell_usage_cmd _cell_usage_set_apn
		_exit 4
	fi

	if [ -e $PROFILE_FILE ]; then
		echo "old APN=$APN, new APN=$apn"
		sed -i "s/APN=.*/APN=$apn/" $PROFILE_FILE
	else
		echo -e "APN=$apn\nusername=\npassword=\nPIN="
	fi
	APN=${apn}

	cell_set_profile 1 "${APN}" "IPV4V6" || _exit 1
	_exit 0
}

# dhclient
cell_dhclient() {
	local node="$1"
	local ignore_dns_gw="$2"


	if [ x"$ignore_dns_gw" == x"1" ];   then
cat << EOF > /etc/dhcp/dhclient-enter-hooks.d/no-default-route
case \$reason in
    BOUND|RENEW|REBIND|REBOOT)
        echo "IP=\$new_ip_address"
        echo "SubnetMask=\$new_subnet_mask"
        echo "Gateway=\$new_routers"
        echo "DNS=\$new_domain_name_servers"
        unset new_domain_name_servers
        unset new_routers
      ;;
esac
EOF
	fi

	dhclient -pf /var/run/dhclient-${node}.pid $node
	rm /etc/dhcp/dhclient-enter-hooks.d/no-default-route 2>/dev/null
}

# udhcpc
cell_udhcpc() {
	local node="$1"
	local ignore_dns_gw="$2"
	local udhcpc_opt=""

	if [ x"$ignore_dns_gw" == x"1" ];   then
		udhcpc_opt="-s /etc/udhcpc/ignore-gw-dns.script"
	fi
	#udhcpc -q -f ${udhcpc_opt} -i $node
	udhcpc -b -R ${udhcpc_opt} -i $node -p /var/run/udhcpc-${node}.pid
}

# module info
cell_module_info() {
	echo SLOT: $SLOT
	echo Module: $MODULE_NAME
	echo WWAN_node: $QMI_NODE
	echo AT_port: $AT_PORT
	echo GPS_port: $GPS_PORT	
	echo QMI_port: $QMI_PORT
	echo Modem_port: $MODEM_PORT
}

# module info (fully)
cell_m_info() {
	local info=""
	local lac=""
	local cellid=""
	local lcid=""
	local ret=""
	local iccid=""
	local imei=""


	iccid="$(_exec_op_rtn iccid | cut -d' ' -s -f 2-)"

	info="$(_exec_op_rtn location_info)"
	cellid="$(echo "${info}" | grep "CellID:" | cut -d' ' -s -f 2-)"
	lac="$(echo "${info}" | grep "LAC:" | cut -d' ' -s -f 2-)"
	lcid="$(echo "${info}" | grep "LCID:" | cut -d' ' -s -f 2-)"

	info="$(_exec_op_rtn module_ids)"
	imei="$(echo "${info}" | grep "IMEI:" | cut -d' ' -s -f 2-)"

	echo Module=$MODULE_NAME
	echo WWAN_node=$QMI_NODE
	echo AT_port=$AT_PORT
	echo GPS_port=$GPS_PORT	
	echo LAC=$lac
	echo CellID=$cellid
	echo ICC-ID=$iccid
	echo IMEI=$imei
	echo QMI_port=$QMI_PORT
	echo LCID=$lcid
	#echo slot=$SLOT
	#echo SYS_USB=$SYS_USB	
}

# verizon auto dialup
cell_vzwauto() {
	local profile=$(_exec_op_rtn get_profiles | grep "^3")


	[ -z "${profile}" ] && \
		>&2 echo "Error: PDP context 3 doesn't exist." && exit 1
	APN=$(echo "${profile}" | cut -d ',' -f 2)
	_exec_op start_network
	#echo -e "\n\n APN=${APN} is in used\n\n"
	_exit 0
}

cell_pin_code_status() {
	local card_status="$(_exec_op sim_status | grep "+CPIN")"


	if [ "$(echo "${card_status}" | grep "READY")" ]; then
		echo "PIN code: Disabled or verified"
	elif [ "$(echo "${card_status}" | grep "PIN")" ]; then
		echo "PIN code: Not Verified"
	elif [ "$(echo "${card_status}" | grep "PUK")" ]; then
		echo "PIN code: Blocked"
		_exit 1
	else
		>&2 echo "Error: SIM card not available, please check."
		_exit 1
	fi
}

_cell_unlock_pin() {
	local pin_code="$1"
	local usage_func="$2"
	local card_status=""


	# unlock PIN
	card_status="$(_exec_op sim_status | grep "+CPIN")"
	if [ "$(echo "${card_status}" | grep "READY")" ]; then
		echo "PIN code: Disabled or verified"
	elif [ "$(echo "${card_status}" | grep "PIN")" ]; then
		echo "PIN code: Not Verified"
		if [ -z "$pin_code" ]; then
			>&2 echo "Error: Please assign the PIN code."
			if [ -z "${usage_func}" ]; then
				_cell_usage_cmd "_cell_usage_unlock_pin"
			else
				_cell_usage_cmd "${usage_func}"
			fi
			_exit 4
		fi
		_exec_op unlock_pin ${pin_code}
		return $?
	elif [ "$(echo "${card_status}" | grep "PUK")" ]; then
		echo "PIN code: Blocked"
		echo "Please unblock PIN first."
		_exit 1
	else
		echo "SIM card not available, please check."
		_exit 1
	fi
}

cell_unlock_pin() {
	local ret=""
	local pin_code="$1"
	local card_status=""



	# save to profile
	if [ -e $PROFILE_FILE ]; then
		echo "old PIN=$PIN, new PIN=$pin_code"
		sed -i "s/PIN=.*/PIN=$pin_code/" $PROFILE_FILE
	else
		echo -e "APN=\nusername=\npassword=\nPIN=$pin_code"
	fi
	PIN=${pin_code}

	_cell_unlock_pin ${PIN}
}

# cellular restart
cell_restart() {
	# restart cellular (reconnect)
	_exec_op stop_network
	sleep 5
	_exec_op start_network
}

cell_sim_status() {
	local ret=$(_exec_op sim_status)


	if [ x"$ret" != x"" ]; then
		echo "$ret"
	else
		>&2 echo "Error: Please insert the sim card and reboot."
		_exit 1
	fi
}

# cell_mgmt setinterface
cell_interface() {
	case $1 in
		"0" | "1" | "2" | "3")
			[ $1 -ge ${#ALL_INTERFACE[@]} ] && \
				>&2 echo "Error: Interface out of range." && \
				_exit 4
			sed -i "s/INTERFACE=.*/INTERFACE=$1/" $PROFILE_FILE
			echo "set interface=$1"
			_exit 0
			;;
		"")
			for (( i=0 ; i<${#ALL_INTERFACE[@]} ; i++ ))
			do
				echo "[$i] ${ALL_INTERFACE[$i]}" \
					"$([ x$i == x$INTERFACE ] &&
						echo '   <Current>')"
			done
			;;
		*)
			>&2 echo "Error: Invalid interface."
			_cell_usage_cmd _cell_usage_interface
			_exit 4
			;;
	esac
}

cell_interfaces() {
	echo ${#ALL_INTERFACE[@]}
}

cell_slot() {
	echo ${SLOT}
}

# cell_mgmt version
cell_version() {
	echo "$PKG $VERSION"
}

# show cell_mgmt usage list
_cell_usage_cmd() {
	echo "Usage:"
	eval "$1"
}

_cell_usage_interface() {
	echo -e "	interface [interface id]"
	echo -e "		Switching and checking module interface(s)"
}

_cell_usage_unlock_pin() {
	echo -e "	unlock_pin <PIN>"
	echo -e "		Unlock PIN code and save to configuration file."
}

_cell_usage_pin_protection() {
	echo -e "	pin_protection <PIN1|PIN2> <enable|disable> <current PIN>"
	echo -e "		Set PIN protection in the UIM."
}

_cell_usage_set_profile() {
	#set_profile
	echo -e "	set_profile <id> [APN [PDP Type]]"
	echo -e "		Update PDP profile."
}

_cell_usage_set_apn() {
	#set_apn 
	echo -e "	set_apn <APN>"
	echo -e "		Set APN to configuration file."
}

_cell_usage_start() {
	echo -e "	start [OPTIONS]"
	echo -e "		Start network."
	echo -e ""
	echo -e "		OPTIONS:"
	echo -e "		APN - Access point name"
	echo -e "		PIN - PIN code"
	echo -e "		Phone - Phone number (especially for AT based modules)"
	echo -e "		Username"
	echo -e "		Password"
	echo -e ""
	echo -e "		example:"
	echo -e "			cell_mgmt start"
	echo -e "			cell_mgmt start APN=internet"
	echo -e "			cell_mgmt start APN=internet PIN=0000"
	echo -e "			cell_mgmt start APN=internet PIN=0000 Phone=*99#"
}

cell_usage() {
	echo -e "Usage: "
	echo -e "	$0 [-i <module id>] [-s <slot id>] <OPTIONS>\n"
	echo -e "OPTIONS"
	echo -e "	-i <module id>"
	echo -e "		Module identifier, start from 0 and default to 0."
	echo -e "	-s <slot id>"
	echo -e "		Slot identifier, start from 1 and default value depends "
	echo -e "		on module interface."
	echo -e "		example: module 0 may in slot 2"
	#modules
	echo -e "	modules"
	echo -e "		Shows module numbers supported."
	#slot
	echo -e "	slot"
	echo -e "		Shows module slot id"
	#interface
	_cell_usage_interface
	#start
	_cell_usage_start
	#stop
	echo -e "	stop"
	echo -e "		Stop network."
	#restart
	echo -e "	restart"
	echo -e "		Restart network."
	#power on
	echo -e "	power_on"
	echo -e "		Power ON."
	#power off 
	echo -e "	power_off"
	echo -e "		Power OFF."
	#power cycle 
	echo -e "	power_cycle"
	echo -e "		Power cycle the module slot."
	#switch sim slot
	echo -e "	switch_sim <1|2>"
	echo -e "		Switch SIM slot."
	#gps on
	echo -e "	gps_on"
	echo -e "		GPS ON."
	#gps off 
	echo -e "	gps_off"
	echo -e "		GPS OFF."
	#attach_status 
	echo -e "	attach_status"
	echo -e "		Query network registration status."
	#status 
	echo -e "	status"
	echo -e "		Query network connection status."
	#signal 
	echo -e "	signal"
	echo -e "		Get signal strength."
	#at 
	echo -e "	at <'AT_COMMAND'>"
	echo -e "		Input AT Command."
	echo -e "		Must use SINGLE QUOTATION to enclose AT Command."
	#sim_status
	echo -e "	sim_status"
	echo -e "		Query sim card status."
	#unlock_pin
	_cell_usage_unlock_pin
	#pin_retries
	echo -e "	pin_retries"
	echo -e "		Get PIN code retry remain times."
	#pin_protection
	_cell_usage_pin_protection
	#set_flight_mode
	echo -e "	set_flight_mode <0|1>"
	echo -e "		Set module into flight mode (1) or online mode (0)."
	#get_profiles
	echo -e "	get_profiles"
	echo -e "		Get profile list."
	echo -e "		format:"
	echo -e "			<id>,<APN>,<PDP Type>"
	echo -e "		example:"
	echo -e "			1,internet,IPV4V6"
	#set_profile
	_cell_usage_set_profile
	#set_apn 
	_cell_usage_set_apn
	#number 
	echo -e "	number"
	echo -e "		Get SIM number."
	#check_carrier 
	echo -e "	check_carrier"
	echo -e "		Check current carrier."
	#switch_carrier 
	echo -e "	switch_carrier <$CARRIER>"
	echo -e "		Switching between US carrier frequency bands."
	#m_info
	echo -e "	m_info"
	echo -e "		Module/SIM information."
	#module_info
	echo -e "	module_info"
	echo -e "		Module information."
	#module_ids
	echo -e "	module_ids"
	echo -e "		Get device IDs (ex: IMEI and/or ESN)."
	#iccid
	echo -e "	iccid"
	echo -e "		Get SIM card ID"
	#location_info
	echo -e "	location_info"
	echo -e "		Get cell location information."
	#operator
	echo -e "	operator"
	echo -e "		Telecommunication operator."
	#verizon auto dial up
	echo -e "	vzwauto"
	echo -e "		Verizon Private Network auto dialup."
	#version
	echo -e "	version"
	echo -e "		Cellular management version."
}


#--------- Initialize Global variables start ---------

init


#--------- Initialize Global variables end ---------

PROG=$0

while getopts  "i:s:" flag; do
	if [ "${flag}" == "i" ]; then
		if [ "${INTERFACE}" != "$OPTARG" ]; then
			INTERFACE=$OPTARG
			_set_variables
		fi
	elif [ "${flag}" == "s" ]; then
		SLOT=$OPTARG
	fi
done

for i in $(seq $OPTIND 1 $#); do
	eval "var=\$$i"
	if [ "${var}" == "force" ]; then
		FORCE=1
		continue
	fi
	j=$(($j + 1))
	eval "arg$j=\$$i"
done


(
	if [ ${FORCE} -eq 0 ]; then
		flock -w 60 9 || \
			{ >&2 echo "Error: ${PROG} is busy, please wait a " \
				"moment and try again." ; _exit 1; }
	fi
	case "$arg1" in
		# private options
		post_start)
			_exec_op post_start
			;;
		# public options
		modules)
			cell_interfaces
			;;
		slot)
			cell_slot
			;;
		start)
			_exec_op start_network $arg2 $arg3 $arg4 $arg5
			;;
		stop)
			_exec_op stop_network
			;;
		restart)
			cell_restart
			;;
		gps_on)
			_exec_op gps_on
			;;
		gps_off)
			_exec_op gps_off
			;;
		power_on)
			cell_power_on
			;;
		power_off)
			cell_power_off
			;;
		power_cycle)
			cell_power_cycle
			;;
		switch_sim)
			cell_switch_sim $arg2
			;;
		attach_status)
			_exec_op attach_status
			;;
		status)
			_exec_op status
			;;
		signal)
			_exec_op signal
			;;
		signal_adv)
			_exec_op signal_adv
			;;
		sim_status)
			cell_sim_status
			;;
		pin_code_status)
			cell_pin_code_status
			;;
		unlock_pin)
			cell_unlock_pin $arg2
			#_exec_op unlock_pin $arg2
			;;
		pin_retries)
			_exec_op pin_retries
			;;
		pin_protection)
			_exec_op pin_protection $arg2 $arg3 $arg4
			;;
		set_flight_mode)
			_exec_op set_flight_mode $arg2
			;;
		get_profiles)
			_exec_op get_profiles
			;;
		set_profile)
			cell_set_profile $arg2 $arg3 $arg4
			;;
		set_apn)
			cell_set_apn $arg2
			;;
		number)
			_exec_op number
			;;
		check_carrier)
			_exec_op check_carrier
			;;
		switch_carrier)
			_exec_op switch_carrier $arg2
			;;
		at)
			cell_at_cmd "$arg2" $arg3
			;;
		version)
			cell_version
			;;
		interface)
			cell_interface $arg2
			;;
		m_info)
			cell_m_info
			;;
		module_info)
			cell_module_info
			;;
		module_ids)
			_exec_op module_ids
			;;
		iccid)
			_exec_op iccid
			;;
		location_info)
			_exec_op location_info
			;;
		operator)
			_exec_op operator
			;;
		service)
			_exec_op service
			;;
		vzwauto)
			cell_vzwauto
			;;
		initialize)
			cell_initialize $arg2
			;;
		help)
			cell_usage	
			;;
		*)
			cell_usage
			_exit 3
			;;
	esac
	RET=$?
	[ ${RET} -ne 0 ] && _exit ${RET}

	if [ ${FORCE} -eq 0 ]; then
		flock -u 9
	fi
) 9> ${LOCK_FILE}
