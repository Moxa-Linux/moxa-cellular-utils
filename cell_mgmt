#!/bin/bash
#
#       Copyright (C) MOXA Inc. All rights reserved.
#       Copyright (C) 2014-2015  Lock Lin <Lock.Lin@moxa.com>
#       Copyright (C) 2015       Harry YJ Jhou <HarryYJ.Jhou@moxa.com>
#
#       This software is distributed under the terms of the
#       MOXA License.  See the file COPYING-MOXA for details.
#
#       cell_mgmt
#               cellular management. It supports sierra MC9090 MC7304 MC7354.
#
 

#--------- Initialize Global variables ---------
PKG="moxa-cellular-utils"
VERSION="1.12.1"
PID=$$
LOCK_FILE=/tmp/cell_mgmt.lock

# profile
CONF_DIR=/etc
#CONF_DIR=/home/moxa/moxa-cellular-utils/etc
PROFILE_FILE=${CONF_DIR}/${PKG}/${PKG}.conf
KVERSION="$(kversion | awk '{print $1}')"
PRODUCT_DIR=${CONF_DIR}/${PKG}/product.d
MODULE_DIR=${CONF_DIR}/${PKG}/module.d

# QMI
# new libqmi includes a tool called "qmi-proxy"
# use qmicli -p means interaction with the QMI interface of modem by "qmi-proxy"
QMICLI="/usr/bin/qmicli"
QMICLI_END="-p"

# variables
FORCE=0


_exit() {
	if [ ${FORCE} -eq 0 ]; then
		flock -u 9 2>/dev/null
	fi
	exit $1
}

_load_profile ()
{
	. $PROFILE_FILE
	for conf in $(ls ${PRODUCT_DIR}); do
		if [ "${conf: -5}" == ".conf" ]; then
			. ${PRODUCT_DIR}/$conf
		fi
	done
	for conf in $(ls ${MODULE_DIR}); do
		if [ "${conf: -5}" == ".conf" ]; then
			. ${MODULE_DIR}/$conf
		fi
	done

	eval "_product_${KVERSION}_profile" 2>/dev/null
	if [ x"$?" != x"0" ]; then
		>&2 echo "Error: kversion or profile not found."
		_exit 9
	fi
}

_search_wwan_node()
{
	local module_name
	local vendor_id
	local product_id
	local slot_num=0

	for i in ${MODULE_PATH[@]}; do
		let slot_num++
		if [ -e $i ]; then
			vendor_id=$(cat $i/idVendor 2> /dev/null)
			product_id=$(cat $i/idProduct 2> /dev/null)
			module_name=$(cat $i/product 2> /dev/null)
			ALL_MODULE_ID[${#ALL_MODULE_ID[@]}]=${vendor_id}_${product_id}
			ALL_MODULE_NAME[${#ALL_MODULE_NAME[@]}]=${module_name}
			ALL_SLOT_NUM[${#ALL_SLOT_NUM[@]}]=$slot_num
			ALL_INTERFACE[${#ALL_INTERFACE[@]}]=""
			ALL_QMI_PROTOCOL[${#ALL_QMI_PROTOCOL[@]}]="802-3"
			ALL_QMI_PORT[${#ALL_QMI_PORT[@]}]="NotSupport"
			ALL_AT_PORT[${#ALL_AT_PORT[@]}]="NotSupport"
			ALL_GPS_PORT[${#ALL_GPS_PORT[@]}]="NotSupport"
			ALL_MODEM_PORT[${#ALL_MODEM_PORT[@]}]="NotSupport"
			ALL_AT_TIMEOUT[${#ALL_AT_TIMEOUT[@]}]="0.3"
		else
			continue
		fi

		eval "_module_${vendor_id}_${product_id} \
			$i $((${slot_num}-1)) \"${module_name}\"" 2>/dev/null
		if [ $? -ne 0 ]; then
			>&2 echo "Error: module ${module_name} not support."
			continue
		fi
	done
}

_set_variables ()
{
	MODULE_ID="${ALL_MODULE_ID[$INTERFACE]}"
	SLOT="${ALL_SLOT_NUM[$INTERFACE]}"
	MODULE_NAME="${ALL_MODULE_NAME[$INTERFACE]}"	
	QMI_PROTOCOL=${ALL_QMI_PROTOCOL[${INTERFACE}]}

	QMI_NODE="${ALL_INTERFACE[$INTERFACE]}"
	if [ x"${ALL_QMI_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		QMI_PORT="NotSupport"
	else
		QMI_PORT="/dev/${ALL_QMI_PORT[$INTERFACE]}"
	fi
	if [ x"${ALL_AT_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		AT_PORT="NotSupport"
	else
		AT_PORT="/dev/${ALL_AT_PORT[$INTERFACE]}"
	fi
	if [ x"${ALL_GPS_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		GPS_PORT="NotSupport"
	else
		GPS_PORT="/dev/${ALL_GPS_PORT[$INTERFACE]}"
	fi
	if [ x"${ALL_MODEM_PORT[$INTERFACE]}" == x"NotSupport" ]; then
		MODEM_PORT="NotSupport"
	else
		MODEM_PORT="/dev/${ALL_MODEM_PORT[$INTERFACE]}"
	fi
	AT_TIMEOUT="${ALL_AT_TIMEOUT[$INTERFACE]}"
}

init()
{
	unset ALL_MODULE_ID
	unset ALL_MODULE_NAME
	unset ALL_SLOT_NUM
	unset ALL_INTERFACE
	unset ALL_QMI_PROTOCOL
	unset ALL_QMI_PORT
	unset ALL_AT_PORT
	unset ALL_GPS_PORT
	unset ALL_MODEM_PORT
	unset ALL_AT_TIMEOUT

	if [ -f $PROFILE_FILE ]; then
		_load_profile
		_search_wwan_node
		_set_variables
	else
		>&2 echo "Error: $PROFILE_FILE does not exist." && _exit
	fi
}

_connect_error_note()
{
	echo "Please check the following items before start LTE connection:"
	echo "  1. Antenna setting"
	echo "  2. SIM card inserted and PIN code unlocked, \`sim_status\`"
	echo "  3. Signal strength \`signal\`"
	echo "  4. Remember to set_apn before start LTE connection"
}

_start_network_init() {
	ignore_dns_gw=0
	local interface_num="$INTERFACE"
	[ x"$interface_num" == x"0" ] && interface_num=""


	APN="$(eval echo \$APN$interface_num)"
	Username="$(eval echo \$Username$interface_num)"
	Password="$(eval echo \$Password$interface_num)"
	PIN="$(eval echo \$PIN$interface_num)" 

	# modify APN Username Password PIN
	for args in $@; do
		for par in "APN" "Username" "Password" "PIN"; do
			if [ $(echo $args | grep "$par=") ]; then
				eval "$par=${args##*$par=}"
				eval "sed -i s/$par$interface_num=.*/$par$interface_num=\$$par/ $PROFILE_FILE"
			fi
		done
		[ x"$args" == x"ignore-dns-gw" ] && ignore_dns_gw=1
	done
	
	# check APN
	if [ x"$(eval echo \$APN$interface_num)" == x"" ]; then
		echo "warning : APN is NULL."
		echo "Usage:"
		echo "	cell_mgmt \"start\"[APN=[APN], Username=[username], Password=[password], PIN=[pin_code]]"
		echo "example:"
		echo "          cell_mgmt start APN=internet Username=user Password=pass PIN=0000"
		_exit 1
	fi
}

#--------- qmi base functions -----------
_qmicli()
{
	local i
	local qmi_cmd=""
	local qmi_std=""
	local qmi_err=""
	local qmi_ret=0
	local cmd=""

	qmi_cmd="$QMICLI -d $QMI_PORT $@ $QMICLI_END"
	#echo ${qmi_cmd}

	for i in {1..5}; do
		eval "$( (${qmi_cmd}) 2> \
			>(qmi_err=$(cat); typeset -p qmi_err) > \
			>(qmi_std=$(cat); typeset -p qmi_std); \
			qmi_ret=$?; typeset -p qmi_ret )"
		# error 3 (internal) and 31 (invalid service type)
		if ! (echo ${qmi_err} | grep "QMI protocol error (3)") && 
			! (echo ${qmi_err} | grep "QMI protocol error (31)"); then
			echo "${qmi_std}"
			return 0
		fi
	done

	# reset qmi service
	>&2 echo "Error: Internal error, please reset module and try again."
	_exit 1
}

_qmicli_value()
{
	local output="$1"
	local key="$2"
	local num="$3"
	local num_opt=""
	local cmd=""

	if [ -z "${3}" ]; then
		num=1
	fi
	num_opt="| sed -n ${num}p"

	cmd="echo \"${output}\" | awk '/${key}:/{ print}' ${num_opt} | \
		sed \"s/^[^:]*: [']*//;s/[' \t]*$//\""
	eval "${cmd}"
}

_qmi_save_state ()
{
	local KEY=$1
	local VAL=$2

	echo "Saving state... ($KEY: $VAL)"

	if [ -f $QMI_STATE_FILE ]; then
		PREVIOUS=`cat $QMI_STATE_FILE 2>/dev/null`
		PREVIOUS=`echo "$PREVIOUS" | grep -v $KEY`
		if [ "x$PREVIOUS" != "x" ]; then
			echo $PREVIOUS > $QMI_STATE_FILE
		else
			rm $QMI_STATE_FILE
		fi
	fi

	if [ "x$VAL" != "x" ]; then
		echo "$KEY=\"$VAL\"" >> $QMI_STATE_FILE
	fi
}

_qmi_load_state ()
{
	if [ -f $QMI_STATE_FILE ]; then
		# Loading previous state
		. $QMI_STATE_FILE
	fi
}

_qmi_clear_state ()
{
	echo "Clearing state..."
	rm -f $QMI_STATE_FILE
}

_qmi_start_network ()
{
	local is_raw_ip="N"
	local raw_ip_file="/sys/class/net/${QMI_NODE}/qmi/raw_ip"

	if [ "x$CID" != "x" ]; then
		USE_PREVIOUS_CID="--client-cid=$CID"
	fi

	if [ "x$PDH" != "x" ]; then
		echo "error: cannot re-start network, PDH already exists" 1>&2
		_exit 3
	fi

	# initialize the interface with protocol
	if [ x"${QMI_PROTOCOL}" == x"802-3" ]; then
		is_raw_ip=N
	elif [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
		is_raw_ip=Y
	else
		QMI_PROTOCOL="802-3"
		is_raw_ip=N
	fi

	if [ -f "${raw_ip_file}" ]; then
		echo ${is_raw_ip} > ${raw_ip_file} 2> /dev/null
	elif [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
		echo "error: raw-ip not supported" 1>&2
		_exit 1
	fi
	_qmicli --set-expected-data-format=${QMI_PROTOCOL}

	#START_NETWORK_CMD="$QMICLI -d $QMI_PORT --wds-start-network=$APN --client-no-release-cid --device-open-net=net-802-3|net-no-qos-header $QMICLI_END"
	START_NETWORK_CMD="_qmicli --wds-start-network='apn=$APN,ip-type=4' --client-no-release-cid --device-open-net=net-${QMI_PROTOCOL}|net-no-qos-header"
	echo "Starting network with '$START_NETWORK_CMD'..."

	if [ "x$QMIDEBUG" != "x" ]; then
		if [ x"$INTERFACE" == x"" -o x"$INTERFACE" == x"1" ]; then
			START_NETWORK_OUT="\
[/dev/cdc-wdm0] Network started
        Packet data handle: '3634026241'
[/dev/cdc-wdm0] Client ID not released:
        Service: 'wds'
        CID: '80'"
		else
			START_NETWORK_OUT="\
[/dev/cdc-wdm1] Network started
        Packet data handle: '363402624$3'
[/dev/cdc-wdm1] Client ID not released:
        Service: 'wds'
        CID: '80'"
		fi
	else
		START_NETWORK_OUT=`$START_NETWORK_CMD`
	fi

	# Save the new CID if we didn't use any before
	if [ "x$CID" = "x" ]; then
		CID=`echo "$START_NETWORK_OUT" | sed -n "s/.*CID.*'\(.*\)'.*/\1/p"`
		if [ "x$CID" = "x" ]; then
			echo "error: network start failed, client not allocated" 1>&2
			_connect_error_note
			_exit 1
		else
			_qmi_save_state "CID" $CID
		fi
	fi

	PDH=`echo "$START_NETWORK_OUT" | sed -n "s/.*handle.*'\(.*\)'.*/\1/p"`
	if [ "x$PDH" = "x" ]; then
		echo "error: network start failed, no packet data handle" 1>&2
		_connect_error_note
		# Cleanup the client
		#$QMICLI -d "$QMI_PORT" --wds-noop --client-cid="$CID" $QMICLI_END
		_qmicli --wds-noop --client-cid="$CID"
		_qmi_clear_state
		_exit 2
	else
		_qmi_save_state "PDH" $PDH
	fi

	echo "Network started successfully"
}

_qmi_stop_network ()
{
	if [ "x$CID" = "x" ]; then
		echo "Network already stopped"
	elif [ "x$PDH" = "x" ]; then
		echo "Network already stopped; need to cleanup CID $CID"
		# Cleanup the client
		#$QMICLI -d "$QMI_PORT" --wds-noop --client-cid="$CID" $QMICLI_END
		_qmicli --wds-noop --client-cid="$CID"
		PDH=""
	else
		#STOP_NETWORK_CMD="$QMICLI -d $QMI_PORT --wds-stop-network=$PDH --client-cid=$CID $QMICLI_END"
		STOP_NETWORK_CMD="_qmicli --wds-stop-network=$PDH --client-cid=$CID"
		echo "Stopping network with '$STOP_NETWORK_CMD'..."

		if [ "x$QMIDEBUG" != "x" ]; then
			STOP_NETWORK_OUT="\
[/dev/cdc-wdm$INTERFACE] Network stopped
"
		else
			STOP_NETWORK_OUT=`$STOP_NETWORK_CMD`
		fi
		PDH=""
		CID=""

		echo "Network stopped successfully"
	fi

	_qmi_clear_state
}

_qmi_packet_service_status ()
{
	if [ "x$CID" != "x" ]; then
		USE_PREVIOUS_CID="--client-cid=$CID --client-no-release-cid"
	fi

	#STATUS_CMD="$QMICLI -d $QMI_PORT --wds-get-packet-service-status $USE_PREVIOUS_CID $QMICLI_END"
	STATUS_CMD="_qmicli --wds-get-packet-service-status $USE_PREVIOUS_CID"
	echo "Getting status with '$STATUS_CMD'..."

	if [ "x$QMIDEBUG" != "x" ]; then
		CONN="disconnected"
	else
		CONN="$(_qmicli_value "$(${STATUS_CMD})" "Connection status")"
	fi

	if [ "x$CONN" = "x" ]; then
		echo "error: couldn't get packet service status" 1>&2
		_exit 2
	else
		echo "Status: $CONN"
		if [ "x$CONN" != "xconnected" ]; then
			_exit 64
		fi
	fi
}

_qmi_kill_proxy() {
	local proxy_pid=`ps wwax | grep -v "grep" | grep "qmi-proxy" | awk '{print $1}'`
	if [ ! -z "${proxy_pid}" ]; then
		kill ${proxy_pid}
	fi
}

_qmi_card_app_state() {
	local app_state="$(_qmicli_value "${1}" "Application state")"

	case "${app_state}" in
		"pin1-or-upin-pin-required")
			echo "+CPIN: SIM PIN"
			;;
		"puk1-or-upin-puk-required")
			echo "+CPIN: SIM PUK"
			;;
		"ready")
			echo "+CPIN: READY"
			;;
		*)
			echo "+CME ERROR: SIM ${app_state}"
			return 1
			;;
	esac
}

_qmi_card_status() {
	local card_info="$(_qmicli --uim-get-card-status)"
	local card_state="$(_qmicli_value "${card_info}" "Card state")"

	case "${card_state}" in
		"absent")
			echo "+CME ERROR: SIM not inserted"
			;;
		"present")
			_qmi_card_app_state "${card_info}"
			;;
		*)
			echo "+CME ERROR: SIM ${card_state}"
			return 1
			;;
	esac
}

#--------- qmi functions -----------

#check cellular status
qmi_status () {
	flock -u 9 2>/dev/null

	local con_status=$(_qmi_packet_service_status | grep "Status")
	echo ${con_status}
	if [ x"$(echo ${con_status}| awk '{print $2}')" == x"connected" ]; then
		_exit 0
	else
		_exit 1
	fi
}

#cellular signal strength in dbm
qmi_signal () {
	flock -u 9 2>/dev/null

	local signal 
	#signal=`$QMICLI -d ${QMI_PORT} --nas-get-signal-strength $QMICLI_END | tr "'" " " | grep "Network" | head -1 | awk '{print $2 " " $4}'`
	signal=`_qmicli --nas-get-signal-strength | tr "'" " " | grep "Network" | head -1 | awk '{print $2 " " $4}'`
	signal_dbm="$(echo $signal | awk '{print $2}')"
	if [ "$signal_dbm" -le "-1" 2>/dev/null ]; then
		echo "${signal} dbm"
		return 0
	else
		echo "signal out of range"
		return 1
	fi
}

# cell_signal_adv
qmi_signal_adv () {
	flock -u 9 2>/dev/null

	local csq
	local rssi
	local ecio
	local signal 
	csq=$(at_signal_csq)

	signal=$(_qmicli --nas-get-signal-strength | \
		 sed "s/'\|'://g;s/^[ \t]*Network //g")
	rssi=$(echo "${signal}" | awk '/Current:/{getline; print}')
	ecio=$(echo "${signal}" | awk '/ECIO:/{getline; print}')

	echo "CSQ: ${csq}"
	echo "RSSI: ${rssi}"
	echo "EcIo: ${ecio}"
	return 0
}

# cell_start
qmi_start_network() {
	local card_status=""
	local ignore_dns_gw=0
	local pin_status
	

	_start_network_init $@
	# Check PIN status
	# if PIN status are not verified
	# use the PIN code user input to verify automatically.
	card_status="$(_qmi_card_status | grep "+CPIN")"
	if [ "$(echo "${card_status}" | grep "READY")" ]; then
		echo "PIN code: Disabled or verified"
	elif [ "$(echo "${card_status}" | grep "PIN")" ]; then
		echo "PIN code: Not Verified"
		_qmicli --uim-verify-pin=PIN1,$PIN
		echo "Please wait ..."
		sleep 10
	elif [ "$(echo "${card_status}" | grep "PUK")" ]; then
		#--uim-unblock-pin=[(PIN1|PIN2|UPIN),(PUK),(new PIN)]
		echo "PIN code: Blocked"
		echo "Please unblock PIN first."
		_exit 1
	else
		echo "SIM card not available, please check."
		_exit 1
	fi

	_qmi_start_network
	# query IP from DHCP Server 
	ip link set ${QMI_NODE} up
	if [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
		cell_udhcpc ${QMI_NODE} $ignore_dns_gw
	else
		cell_dhclient ${QMI_NODE} $ignore_dns_gw
	fi

	_exit 0
}

# cell_stop
qmi_stop_network() {
	# release IP by dhclient -r
	if [ x"${QMI_NODE}" != x"" ]; then
		if [ x"${QMI_PROTOCOL}" == x"raw-ip" ]; then
			cat /var/run/udhcpc-${QMI_NODE}.pid 2> /dev/null| \
				xargs --no-run-if-empty kill
		else
			dhclient -r ${QMI_NODE}
		fi
	fi
	# cellular stop by qmi-network
	_qmi_stop_network
}

qmi_sim_status() {
	_qmi_card_status
}

qmi_pin_retries() {
	# [/dev/cdc-wdm0] PIN status retrieved successfully
	# [/dev/cdc-wdm0] PIN1:
	#	Status: enabled-verified
	#	Verify: 3
	#	Unblock: 10
	# [/dev/cdc-wdm0] PIN2:
	#	Status: blocked
	#	Verify: 0
	#	Unblock: 10

	local pin_info="$(_qmicli --dms-uim-get-pin-status)"
	local pin_status="$(_qmicli_value "${pin_info}" "Status" 1)"
	local pin_retries="$(_qmicli_value "${pin_info}" "Verify" 1)"

	case "${pin_status}" in
		"enabled-verified"|"enabled-not-verified")
			echo ${pin_retries}
			;;
		*)
			echo 0
			;;
	esac
}

# sim card pin code protection
qmi_pin_protection (){
	local pin_num="$1"
	local pin_enable="$2"
	local pin_current="$3"
	local par_fail="0"		
	# user does not give current pin
	[ $# -ne 3 ] && par_fail="1"
	[ x"$pin_num" != x"PIN1" ] && [ x$pin_num != x"PIN2" ] && par_fail="1"
	[ x"$pin_enable" != x"enable" ] && [ x$pin_enable != x"disable" ] && par_fail="1"

	if [ $par_fail = "1" ]; then
		echo "Usage: cell_mgmt pin_protection [PIN1|PIN2] [enable|disable] [current_PIN]"
		_exit 1
	else
		#$QMICLI -d $QMI_PORT --uim-set-pin-protection=$pin_num,$pin_enable,$pin_current $QMICLI_END
		_qmicli --uim-set-pin-protection=$pin_num,$pin_enable,$pin_current
		_exit 0
	fi

}

qmi_module_ids() {
	local info="$(_qmicli --dms-get-ids)"
	local imei=$(_qmicli_value "${info}" "IMEI")
	local esn=$(_qmicli_value "${info}" "ESN")

	echo IMEI: $imei
	echo ESN: $esn
}

qmi_iccid() {
	local iccid=$(_qmicli_value "$(_qmicli --dms-uim-get-iccid)" "ICCID")
	echo ICC-ID: $iccid
}

qmi_location_info() {
	local info=""
	local service=""
	local lac=""
	local tac=""
	local cellid=""
	local bid=""
	local nid=""
	local lcid=""


	info="$(_qmicli --nas-get-cell-location-info)"
	service="$(echo "${info}" | sed -n 2p | sed 's/[\t ]Info//g')"
	if [[ ${service} == CDMA* ]]; then
		bid=$(_qmicli_value "${info}" "Base Station ID")
		nid=$(_qmicli_value "${info}" "Network ID")
	elif [ "${service}" == "Intrafrequency LTE" ]; then
		cellid=$(_qmicli_value "${info}" "Global Cell ID")
		tac=$(_qmicli_value "${info}" "Tracking Area Code")
	else
		cellid=$(_qmicli_value "${info}" "Cell ID")
		lac=$(_qmicli_value "${info}" "Location Area Code")
		lcid=$(_qmicli_value "${info}" "${service} Cell ID")
	fi

	# for UMTS
	if [ x"$lac" != x"" ]; then
		echo LAC: $lac
	fi
	# for LTE
	if [ x"$tac" != x"" ]; then
		echo TAC: $tac
	fi
	# for CDMA
	if [ x"$nid" != x"" ]; then
		echo NID: $nid
	fi

	# for UMTS & LTE
	if [ x"$cellid" != x"" ]; then
		echo CellID: $cellid
	fi
	# for CDMA
	if [ x"$bid" != x"" ]; then
		echo BID: $bid
	fi

	if [ x"$lcid" != x"" ]; then
		echo LCID: $lcid
	fi
}

#--------- at functions -----------

# AT command 
cell_at_cmd() {
	local cmd="$1"
	local timeout="$2"


	if [ x"$cmd" == x"" ]; then
		echo "command is null."
		return
	fi

	if [ x"${AT_PORT}" == x"/dev/" ]; then
		echo "modem port not found."
		return
	fi

	if [ x"$timeout" == x"" ]; then
		timeout="${AT_TIMEOUT}"
	fi

	#stty -F ${AT_PORT} -echo raw
	#echo -n -e "ATE0\r\n" > ${AT_PORT}
	#timeout 0.3 cat ${AT_PORT} >/dev/null
	echo -n -e "$cmd\r\n" > ${AT_PORT}
	timeout $timeout cat ${AT_PORT} | tr -d '\r'
}

at_signal_csq () {
	local signal

	signal=$(cell_at_cmd 'AT+CSQ\r\n')
	if $(echo "${signal}" | grep -q "ERROR"); then
		echo "-1"
		_exit 1
	fi
	signal=$(echo "${signal}" | grep "+CSQ" | awk '{print $2}' | cut -d',' -f1)
	echo ${signal}
}

at_signal () {
	local signal

	signal=$(cell_at_cmd 'AT+CSQ\r\n' | awk '{print $2}')
	signal=${signal##*AT}
	signal=${signal%%,*}
	
	if [ x"$signal" != x"" ]; then
		if [ "$signal" -le "30" 2>/dev/null ] && [ "$signal" -ge "2" 2>/dev/null ] ; then
			let signal=signal-2
			let signal=signal*2-109
			# FIXME: not always be umts
			echo "umts $signal dbm"	
		else
			echo "signal out of range"
		fi
	else
		echo "signal out of range"
	fi
}

at_sim_status() {
	cell_at_cmd 'AT+CPIN?' | grep '+CPIN:'
}

# set pin code
at_unlock_pin() {
	local ret
	local pin_code="$1"
	[ -z $pin_code ] && echo "Usage: cell_mgmt unlock_pin [pin_code]" && _exit 1
	if [ -e $PROFILE_FILE ]; then
		echo "old PIN=$PIN, new PIN=$pin_code"
		sed -i "s/PIN=.*/PIN=$pin_code/" $PROFILE_FILE
		if [ x"$(at_sim_status |grep READY)" == x"" ]; then
			ret=$(cell_at_cmd "AT+CPIN=$pin_code" | grep 'ERROR')
			if [ x"$ret" != x"" ]; then
				echo $ret
				_exit 8
			fi
		fi
		#verify pin code
		#$QMICLI -d $QMI_PORT --uim-verify-pin=PIN1,$pin_code $QMICLI_END
	else
		echo -e "APN=\nusername=\npassword=\nPIN=$pin_code"
	fi
	_exit 0
}

# set apn into PDP context id 1
at_set_apn () {

	local ret
	local apn="$1"
	[ -z $apn ] && echo "Usage: cell_mgmt set_apn [apn]" && _exit 1
	if [ -e $PROFILE_FILE ]; then
		echo "old APN=$APN, new APN=$apn"
		sed -i "s/APN=.*/APN=$apn/" $PROFILE_FILE
	else
		echo -e "APN=$apn\nusername=\npassword=\nPIN="
	fi
	APN=${apn}
	cell_at_cmd 'AT+CFUN=4' 0.8 > /dev/null
	cell_at_cmd "AT+CGDCONT=1,\"IPV4V6\",\"$APN\"" 1 > /dev/null
	cell_at_cmd 'AT+CFUN=1' 0.5 > /dev/null
	_exit 0
}

# +CNUM: "ABC","12345678901",129
# OK
at_number() {
	number=$(cell_at_cmd 'AT+CNUM?' | grep "+CNUM" | head -1 | sed 's/"//g')
	if [ ! -z "${number}" ]; then
		echo $(echo "${number}" | cut -d ',' -f 2)
	else
		echo "No number."
	fi
}

# telecommunication operator
at_operator () {
	local result
	result=$(cell_at_cmd 'AT+COPS?' | grep COPS:)
	result=${result#*,\"}
	result=${result%%\",*}
	if [ x"$(echo $result | grep COPS)" != x ]; then
		echo "Unknown telecom operator"
	else
		echo $result
	fi
}

at_location_info() {
	local ret=
	local lac=""
	local cellid=""

	cell_at_cmd 'AT+CREG=2' > /dev/null
	ret=$(cell_at_cmd 'AT+CREG?' | grep '+CREG:' )
	[ "${#ret}" -lt "11" ] && ret=""
	if [ x"$ret" != x"" ]; then
		lac=${ret#*\"}
		lac=${lac%%\"*}
		cellid=${ret%\"*}
		cellid=${cellid##*\"}
	fi

	if [ x"$lac" != x"" ]; then
		echo LAC: $lac
	fi
	if [ x"$cellid" != x"" ]; then
		echo CellID: $cellid
	fi
}

at_module_ids() {
	local info="$(cell_at_cmd 'ATI')"
	local imei=$(echo "${info}" | grep "IMEI:" | awk '{print $2}')
	local esn=$(echo "${info}" | grep "ESN:" | awk '{print $2}')

	echo IMEI: $imei
	echo ESN: $esn
}

#--------- generic functions -----------

_cell_initialize() {
	module_id="${ALL_MODULE_ID[$1]}"
	if _func_exist _module_${module_id}_initialize; then
		_module_${module_id}_initialize
	fi
}

cell_initialize() {
	if [ "$1" == "all" ]; then
		for (( i=0 ; i<${#ALL_INTERFACE[@]} ; i++ )); do
			_cell_initialize $i
		done
	else
		_cell_initialize ${INTERFACE}
	fi
}

# cellular power on by GPIO
cell_power_on () {
	local vendor_id=""
	local product_id=""
	local module_id=""
	local power_on_funcs="$(echo "$POWER_ON_FUN" | sed -e "s/\$SLOT/$SLOT/g")"

	IFS=$'\n'
	for i in $power_on_funcs ;
	do
		eval "$i"
	done

	while ((1))
	do
		product_id=$(cat ${MODULE_PATH[$((SLOT-1))]}/idProduct \
			 2> /dev/null)
		if [ x"${product_id}" != x"" ]; then
			vendor_id=$(cat ${MODULE_PATH[$((SLOT-1))]}/idVendor \
				2> /dev/null)

			# initialize after power_on
			module_id=${vendor_id}_${product_id}
			if _func_exist _module_${module_id}_initialize; then
				_module_${module_id}_initialize
			fi
			break;
		fi

		sleep 1
	done
}

# cellular power off by GPIO
cell_power_off () {
	_exec_op_rtn stop_network 2> /dev/null
	_qmi_kill_proxy
	

	power_off_funcs="$(echo "$POWER_OFF_FUN" | sed -e "s/\$SLOT/$SLOT/g")"

	IFS=$'\n'
	for i in $power_off_funcs; do
		eval "$i"
	done

	while ((1)); do
		product_id=$(cat ${MODULE_PATH[$((SLOT-1))]}/idProduct \
			 2> /dev/null)
		if [ x"${product_id}" == x"" ]; then
			break;
		fi

		sleep 1
	done
}

#cellular power off and on by GPIO
cell_power_cycle () {
	cell_power_off
	sleep 1
	cell_power_on
}

# dhclient
cell_dhclient () {
	local node="$1"
	local ignore_dns_gw="$2"


	if [ x"$ignore_dns_gw" == x"1" ];   then
cat << EOF > /etc/dhcp/dhclient-enter-hooks.d/no-default-route
case \$reason in
    BOUND|RENEW|REBIND|REBOOT)
        echo "IP=\$new_ip_address"
        echo "SubnetMask=\$new_subnet_mask"
        echo "Gateway=\$new_routers"
        echo "DNS=\$new_domain_name_servers"
        unset new_domain_name_servers
        unset new_routers
      ;;
esac
EOF
	fi

	dhclient $node
	rm /etc/dhcp/dhclient-enter-hooks.d/no-default-route 2>/dev/null
}

# udhcpc
cell_udhcpc () {
	local node="$1"
	local ignore_dns_gw="$2"
	local udhcpc_opt=""

	if [ x"$ignore_dns_gw" == x"1" ];   then
		udhcpc_opt="-s /etc/udhcpc/ignore-gw-dns.script"
	fi
	#udhcpc -q -f ${udhcpc_opt} -i $node
	udhcpc -b -R ${udhcpc_opt} -i $node -p /var/run/udhcpc-${node}.pid
}

# module info
cell_module_info() {
	echo SLOT: $SLOT
	echo Module: $MODULE_NAME
	echo WWAN_node: $QMI_NODE
	echo AT_port: $AT_PORT
	echo GPS_port: $GPS_PORT	
	echo QMI_port: $QMI_PORT
	echo Modem_port: $MODEM_PORT
}

# module info (fully)
cell_m_info() {
	local info=""
	local lac=""
	local cellid=""
	local lcid=""
	local ret=""
	local iccid=""
	local imei=""


	iccid=$(_exec_op_rtn iccid | cut -d' ' -f 2-)

	info="$(_exec_op_rtn location_info)"
	cellid="$(echo "${info}" | grep "CellID:" | cut -d' ' -f 2-)"
	lac="$(echo "${info}" | grep "LAC:" | cut -d' ' -f 2-)"
	lcid="$(echo "${info}" | grep "LCID:" | cut -d' ' -f 2-)"

	info="$(_exec_op_rtn module_ids)"
	imei="$(echo "${info}" | grep "IMEI:" | cut -d' ' -f 2-)"

	echo Module=$MODULE_NAME
	echo WWAN_node=$QMI_NODE
	echo AT_port=$AT_PORT
	echo GPS_port=$GPS_PORT	
	echo LAC=$lac
	echo CellID=$cellid
	echo ICC-ID=$iccid
	echo IMEI=$imei
	echo QMI_port=$QMI_PORT
	echo LCID=$lcid
	#echo slot=$SLOT
	#echo SYS_USB=$SYS_USB	
}

# verizon auto dialup
cell_vzwauto () {
	result=$(cell_at_cmd 'AT+CGDCONT?'|grep '+CGDCONT: 3')
	APN=`echo $result|cut -d ',' -f 3|tr -d '"'`
	export APN=${APN}
	_exec_op start_network
	echo -e "\n\n APN=${APN} is in used\n\n"
}

cell_pin_code_status () {
	local card_status="$(_exec_op sim_status | grep "+CPIN")"


	if [ "$(echo "${card_status}" | grep "READY")" ]; then
		echo "PIN code: Disabled or verified"
	elif [ "$(echo "${card_status}" | grep "PIN")" ]; then
		echo "PIN code: Not Verified"
	elif [ "$(echo "${card_status}" | grep "PUK")" ]; then
		echo "PIN code: Blocked"
		_exit 1
	else
		>&2 echo "Error: SIM card not available, please check."
		_exit 1
	fi
}

# cellular restart
cell_restart () {
	# restart cellular (reconnect)
	_exec_op stop_network
	sleep 5
	_exec_op start_network
}

cell_sim_status() {
	local ret=$(_exec_op sim_status)


	if [ x"$ret" != x"" ]; then
		echo "$ret"
	else
		>&2 echo "Error: Please insert the sim card and reboot."
		_exit 1
	fi
}

# cell_mgmt setinterface
cell_interface () {

	case $1 in
		"0" | "1" | "2" | "3")
			[ $1 -ge ${#ALL_INTERFACE[@]} ] && echo "Interface out of range." && _exit 1 
			sed -i "s/INTERFACE=.*/INTERFACE=$1/" $PROFILE_FILE
			echo "set interface=$1"
			_exit 0
			;;
		"")
			for (( i=0 ; i<${#ALL_INTERFACE[@]} ; i++ ))
			do
				echo "[$i] ${ALL_INTERFACE[$i]}$([ x$i == x$INTERFACE ] && echo '   <Current>')"
			done
			;;
		*)
			echo "Usage: cell_mgmt \"interface\" [0~3]"
			echo "example:"
			echo "          cell_mgmt interface 0"
			_exit 1
			;;
	esac

}

cell_interfaces() {
	echo ${#ALL_INTERFACE[@]}
}

cell_slot() {
	echo ${SLOT}
}

# cell_mgmt version
cell_version () {
	echo "$PKG $VERSION"
}

# show cell_mgmt usage list
cell_usage () {
	echo -e "Usage: "
	echo -e "      $0 [-i <module id>] [-s <slot id>] [OPTIONS]\n"
	echo -e "OPTIONS"
	echo -e "	-i <module id>"
	echo -e "		Module identifier, start from 0 and default to 0."
	echo -e "	-s <slot id>"
	echo -e "		Slot identifier, start from 1 and default value depends "
	echo -e "		on module interface."
	echo -e "		example: module 0 may in slot 2"
	#modules
	echo -e "	modules"
	echo -e "		Shows module numbers supported."
	#slot
	echo -e "	slot"
	echo -e "		Shows module slot id"
	#interface
	echo -e "       interface [#slot]"	
	echo -e "		Switching and checking module slot."
	#start
	echo -e "       start [APN=[APN],Username=[user],Password=[pass],PIN=[pin_code]]"
	echo -e "		Start network."
	echo -e ""
 	echo -e "               example:"
	echo -e "                       cell_mgmt start"
	echo -e "                       cell_mgmt start APN=internet"
	echo -e "                       cell_mgmt start APN=internet PIN=0000"
	echo -e "                       cell_mgmt start APN=internet Username=moxa Password=pass PIN=0000"
	#stop
	echo -e "       stop"	
	echo -e "		Stop network."
	#restart
	echo -e "       restart"	
	echo -e "		Restart network."
	#power on
	echo -e "       power_on"	
	echo -e "		Power ON."
	#power off 
	echo -e "       power_off"	
	echo -e "		Power OFF."
	#power cycle 
	echo -e "       power_cycle"	
	echo -e "		Power cycle"
	#gps on
	echo -e "       gps_on"	
	echo -e "		GPS ON."
	#gps off 
	echo -e "       gps_off"	
	echo -e "		GPS OFF."
	#status 
	echo -e "       status"	
	echo -e "		Query network connection status."
	#signal 
	echo -e "       signal"	
	echo -e "		Get signal strength."
	#at 
	echo -e "       at ['AT_COMMAND']"	
	echo -e "		Input AT Command."
	echo -e "		Must use SINGLE QUOTATION to enclose AT Command."
	#sim_status
	echo -e "       sim_status"	
	echo -e "		Query sim card status."
	#unlock_pin 
	echo -e "       unlock_pin [PIN]"	
	echo -e "		Unlock PIN code and save to configuration file."
	#pin_retries
	echo -e "       pin_retries"
	echo -e "		Get PIN code retry remain times."
	#protection_pin 
	echo -e "       pin_protection [PIN1|PIN2] [enable|disable] [current_PIN]"
	echo -e "		Set PIN protection in the UIM."
	#set_apn 
	echo -e "       set_apn [APN]"	
	echo -e "		Set APN to configuration file."
	#number 
	echo -e "       number"	
	echo -e "		Get SIM number."
	#check_carrier 
	echo -e "       check_carrier"	
	echo -e "		Check current carrier."
	#switch_carrier 
	echo -e "       switch_carrier [$CARRIER]"	
	echo -e "		Switching between US carrier frequency bands."
	#m_info
	echo -e "       m_info"	
	echo -e "		Module information."
	#operator
	echo -e "       operator"	
	echo -e "		Telecommunication operator."
	#verizon auto dial up
	echo -e "       vzwauto"	
	echo -e "		Verizon Private Network auto dialup."
	#version
	echo -e "       version"	
	echo -e "		Cellular management version."
}


#--------- Initialize Global variables start ---------

init

# state file for different interface
if [ x"$INTERFACE" == x"" -o x"$INTERFACE" == x"0" ]; then
	QMI_STATE_FILE=/tmp/qmi-network-state
else
	QMI_STATE_FILE=/tmp/qmi-network-state$INTERFACE
fi

# Load previous state, if any
_qmi_load_state

#--------- Initialize Global variables end ---------

while getopts  "i:s:" flag; do
	if [ "${flag}" == "i" ]; then
		if [ "${INTERFACE}" != "$OPTARG" ]; then
			INTERFACE=$OPTARG
			_set_variables
		fi
	elif [ "${flag}" == "s" ]; then
		SLOT=$OPTARG
	fi
done

for i in $(seq $OPTIND 1 $#); do
	eval "var=\$$i"
	if [ "${var}" == "force" ]; then
		FORCE=1
		continue
	fi
	j=$(($j + 1))
	eval "arg$j=\$$i"
done

_func_exist() {
	if type ${1} 2> /dev/null | grep -q 'function' 2>/dev/null; then
		return 0
	fi
	return 1
}

_get_op_func() {
	local op="$1"

	if _func_exist _module_${MODULE_ID}_${op}; then
		echo _module_${MODULE_ID}_${op}
	elif [ "${QMI_PORT}" != "NotSupport" ] && _func_exist qmi_${op}; then
		echo qmi_${op}
	elif [ "${AT_PORT}" != "NotSupport" ] && _func_exist at_${op}; then
		echo at_${op}
	else
		echo ""
	fi
}

_exec_op_rtn() {
	local func="$(_get_op_func $1)"

	if [ x"${func}" != x"" ]; then
		#echo "eval ${func} ${@:2}"
		eval ${func} ${@:2}
	else
		>&2 echo "error: operation not support."
		return 1
	fi
}

_exec_op() {
	local func="$(_get_op_func $1)"

	if [ x"${func}" == x"" ]; then
		>&2 echo "error: operation not support."
		_exit 1
	fi

	#echo "eval ${func} ${@:2}"
	eval ${func} ${@:2}
}

(
	if [ ${FORCE} -eq 0 ]; then
		flock -w 60 9 || { echo "cell_mgmt is busy, please wait a moment and try again" ; _exit 1; }
	fi
	case "$arg1" in
		modules)
			cell_interfaces
			;;
		slot)
			cell_slot
			;;
		start)
			_exec_op start_network $arg2 $arg3 $arg4 $arg5
			;;
		stop)
			_exec_op stop_network
			;;
		restart)
			cell_restart
			;;
		gps_on)
			_exec_op gps_on
			;;
		gps_off)
			_exec_op gps_on
			;;
		power_on)
			cell_power_on
			;;
		power_off)
			cell_power_off
			;;
		power_cycle)
			cell_power_cycle
			;;
		status)
			_exec_op status
			;;
		signal)
			_exec_op signal
			;;
		signal_adv)
			_exec_op signal_adv
			;;
		sim_status)
			cell_sim_status
			;;
		pin_code_status)
			cell_pin_code_status
			;;
		unlock_pin)
			_exec_op unlock_pin $arg2
			;;
		pin_retries)
			_exec_op pin_retries
			;;
		pin_protection)
			_exec_op pin_protection $arg2 $arg3 $arg4
			;;
		set_apn)
			_exec_op set_apn $arg2
			;;
		number)
			_exec_op number
			;;
		check_carrier)
			_exec_op check_carrier
			;;
		switch_carrier)
			_exec_op switch_carrier $arg2
			;;
		at)
			cell_at_cmd "$arg2" $arg3
			;;
		version)
			cell_version
			;;
		interface)
			cell_interface $arg2
			;;
		m_info)
			cell_m_info
			;;
		module_info)
			cell_module_info
			;;
		module_ids)
			_exec_op module_ids
			;;
		iccid)
			_exec_op iccid
			;;
		location_info)
			_exec_op location_info
			;;
		operator)
			_exec_op operator
			;;
		vzwauto)
			cell_vzwauto
			;;
		initialize)
			cell_initialize $arg2
			;;
		help)
			cell_usage	
			;;
		*)
			cell_usage
			_exit 3
			;;
	esac

	if [ ${FORCE} -eq 0 ]; then
		flock -u 9
	fi
) 9> ${LOCK_FILE}
