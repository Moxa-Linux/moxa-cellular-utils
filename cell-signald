#!/bin/bash

INTERVAL=10
CELL_MGMT=cell_mgmt
MAX_SLOT_NUM=0
USED_SLOT_NUM=0
SIGNAL_FROM_SLOTS=()

# profile
CONF_DIR=/etc/moxa-cellular-utils
PRODUCT_DIR=${CONF_DIR}/product.d

KVERSION=$(which kversion)
[ -z "${KVERSION}" ] && >&2 echo "Error: \`kversion\` not found." && exit 1

PRODUCT="$(${KVERSION} 2> /dev/null | awk '{print $1}')"

_calc_max_slot_num() {
	for conf in $(ls ${PRODUCT_DIR}); do
		if [ "${conf: -5}" == ".conf" ]; then
			. ${PRODUCT_DIR}/$conf
		fi
	done

	eval "_product_${PRODUCT}_profile" 2>/dev/null
	if [ x"$?" != x"0" ]; then
		>&2 echo "Error: \`kversion\` or profile not found."
		_exit 1
	fi

	MAX_SLOT_NUM=${#MODULE_PATH[@]}
}

_init_signal_from_slots() {
	for (( i=0; i<${MAX_SLOT_NUM}; i++ )); do
		# set to 999 for slot unused
		SIGNAL_FROM_SLOTS[i]=999

		# turn off all slots leds
		_signal_led_flush $((i+1))
	done
	USED_SLOT_NUM=0
}

_calc_used_slot_num() {
	count=0
	for (( i=0; i<${MAX_SLOT_NUM}; i++ )); do
		if [ ${SIGNAL_FROM_SLOTS[i]} -ne 999 ]; then
			count=$((count+1))
		fi
	done
	USED_SLOT_NUM=${count}
}

_signal_led_flush() {
	slot=$1
	local i=""
	if [ -z "$SIGNAL_LED_FLUSH" ]; then
		# Operation not supported. Return.
		return
	fi

	# Use product config signal led flush
	signal_led_flush_funcs="$(echo "$SIGNAL_LED_FLUSH" | \
				sed -e "s/\$SLOT/$slot/g")"
	IFS=$'\n'
	for i in $signal_led_flush_funcs; do
		eval "$i"
	done
}

_signal_led() {
	slot=$1
	signal=$2

	#echo slot: $slot
	#echo signal: $signal
	if [ "$signal" == "signal out of range" ]; then
		_signal_led_flush ${slot}
		return
	fi
	signal=$(echo "$signal" | awk 'END {print $(NF-1)}')

	if [ $signal -ge -70 ]; then
		#echo "Excellent"
		if [ -n "$SIGNAL_LED_EXCELLENT" ]; then
			# Use product config to signal led.
			signal_led_funcs="$(echo "$SIGNAL_LED_EXCELLENT" | \
					sed -e "s/\$SLOT/$slot/g")"
		else
			# Operation not supported. Return.
			return
		fi
	elif [ $signal -ge -100 ]; then
		#echo "Fair"
		if [ -n "$SIGNAL_LED_FAIR" ]; then
			# Use product config to signal led.
			signal_led_funcs="$(echo "$SIGNAL_LED_FAIR" | \
					sed -e "s/\$SLOT/$slot/g")"
		else
			# Operation not supported. Return.
			return
		fi
	elif [ $signal -ge -110 ]; then
		#echo "Poor"
		if [ -n "$SIGNAL_LED_POOR" ]; then
			# Use product config to signal led.
			signal_led_funcs="$(echo "$SIGNAL_LED_POOR" | \
					sed -e "s/\$SLOT/$slot/g")"
		else
			# Operation not supported. Return.
			return
		fi
	else
		#echo "No signal"
		_signal_led_flush ${slot}
		return
	fi

	IFS=$'\n'
	for i in $signal_led_funcs; do
		eval "$i"
	done
}

_loop() {
	while [ 1 ]; do
		modules=$(${CELL_MGMT} modules)

		# when module uninstall from slot, turn off all leds,
		# then turn on still installed modules' leds
		_calc_used_slot_num
		if [ ${modules} -lt ${USED_SLOT_NUM} ]; then
			_init_signal_from_slots
		fi
		for i in $(seq 0 $((modules-1))); do
			slot=$(${CELL_MGMT} -i $i slot)
			signal=$(${CELL_MGMT} -i $i signal)
			_signal_led ${slot} "${signal}"

			# record signal in $SIGNAL_FROM_SLOTS
			SIGNAL_FROM_SLOTS[$((slot-1))]=${signal}
		done

		sleep ${INTERVAL}
	done
}

usage() {
	echo "Usage:"
	echo "  $1 [OPTION]"
	echo ""
	echo "Options:"
	echo "  -i <polling interval>"
	echo "		Polling interval in seconds to update the signal LED"
	echo "  -h"
	echo "		Show help"
	echo "  -v"
	echo "		Print version"
}


while getopts  "i:vh" flag; do
	if [ "${flag}" == "i" ]; then
		re='^[0-9]+$'
		if ! [[ $OPTARG =~ $re ]] ; then
			   echo "error: Interval should be a number" >&2
			   usage $0
			   exit 1
		fi
		INTERVAL=$OPTARG
	elif [ "${flag}" == "h" ]; then
		usage $0
		exit 0
	elif [ "${flag}" == "v" ]; then
		${CELL_MGMT} version
		exit 0
	fi
done

_calc_max_slot_num
_init_signal_from_slots
_loop
