#!/bin/bash
#
#       Copyright (C) MOXA Inc. All rights reserved.
#       Copyright (C) 2017-2018  Aeluin Chen <aeluin.chen@moxa.com>
#
#       This software is distributed under the terms of the
#       MOXA License.  See the file COPYING-MOXA for details.
#

# u-blox
# Vendor ID: 1546
# https://www.u-blox.com/sites/default/files/u-blox-CEL_ATCommands_%28UBX-13002752%29.pdf
# https://www.u-blox.com/sites/default/files/TOBY-L2_DataSheet_%28UBX-13004573%29.pdf
# https://www.u-blox.com/sites/default/files/TOBY-L2-NetworkingModes_AppNote_%28UBX-14000479%29.pdf

# ublox module may combine a cellular and a gps
# - usb hub: 0451-2046 0424-2513
#   - LARA-R2: cellular (1546-1101) + gps (1546-01a8)
#   - TOBY-L2: cellular (1546-114x) + gps (1546-01a8)
#     - different usb mode has different product id
#       - 1140: initial mode to load the specified usb mode as follows
#         - 1141: ppp (+UUSBCONF=0, 6 CDC-ACM)
#         - 1146: rndis (+UUSBCONF=3, 1 CDC-ACM, RNDIS)
#         - 114x: ecm (+UUSBCONF=2, 3 CDC-ACM, ECM)

# ublox module hub
_module_hub_init() {
	local module_path=${1}
	local id=${2}
	local module_name="${3}"
	local dev_id=${module_path//\/*\//}

	local _vendor_id=
	local _product_id=
	local _module_name=


	for _i in $(ls -d ${module_path}/${dev_id}.*); do
		_vendor_id=$(cat $_i/idVendor 2> /dev/null)
		_product_id=$(cat $_i/idProduct 2> /dev/null)
		_module_name=$(cat $_i/product 2> /dev/null)

		_module_func=_module_${_vendor_id}_${_product_id}
		if ! _func_exist ${_module_func}; then
			>&2 echo "Error: Module \"${_module_name}\"" \
				"not supported."
			let unsupport_num++
			continue
		fi

		eval "${_module_func} \
			$_i ${id} \"${_module_name}\"" 2>/dev/null
		if [ $? -ne 0 ]; then
			>&2 echo "Error: Initialize module"\
				"\"${ALL_MODULE_NAME[$id]}\" failed."
		continue
		fi

	done
}

_module_0451_2046() {
	_module_hub_init $@
}

_module_0424_2513() {
	_module_hub_init $@
}

_module_0424_2513_initialize() {
	# A HUB, not a module actually.
	return 0
}
_module_0424_2513_status() {
	echo "NotSupport"
}

# GPS
_module_1546_01a8() {
	local module_path=${1}
	local id=${2}
	local module_name="${3}"
	local dev_id=${module_path//\/*\//}

	ALL_GPS_PORT[${id}]=$(ls \
		$module_path/$dev_id:*.0/tty/ 2>/dev/null | grep tty)
}

# LARA-R2 series
# initial mode
_module_8087_0716() {
	local module_path=${1}
	local id=${2}
	local dev_id=${module_path//\/*\//}

	local i=10
	while ((i--)); do
		product_id=$(cat ${module_path}/idProduct \
			2> /dev/null)
		if [ x"${product_id}" = x"110a" ]; then
			sleep 1 # wait for initialize
			_module_1546_110a $@
			return 0
		fi
		sleep 1
	done
}
# cellular module
_module_1546_110a() {
	local module_path=${1}
	local id=${2}
	local module_name="${3}"
	local dev_id=${module_path//\/*\//}

	ALL_MODULE_ID[${id}]=1546_110a
	ALL_MODULE_NAME[${id}]="u-blox LARA-R2 series"
	ALL_MODEM_PORT[${id}]=$(ls \
		$module_path/$dev_id:*.2/tty/ 2>/dev/null | grep tty)
	ALL_AT_PORT[${id}]=$(ls \
		$module_path/$dev_id:*.0/tty/ 2>/dev/null | grep tty)
	ALL_AT_PORT_RESV[${id}]=$(ls \
		$module_path/$dev_id:*.4/tty/ 2>/dev/null | grep tty)
}

# TOBY-L2 series
# initial mode
_module_1546_1140() {
	local i=10
	while ((i--)); do
		product_id=$(cat ${MODULE_PATH[$((SLOT-1))]}/idProduct \
			2> /dev/null)
		if [ x"${product_id}" = x"1146" ]; then
			sleep 1 # wait for initialize
			_module_1546_1146 $@
			return 0
		fi
		sleep 1
	done
}
# ppp mode
_module_1546_1141() {
	local module_path=${1}
	local id=${2}
	local module_name="${3}"
	local dev_id=${module_path//\/*\//}

	ALL_MODULE_ID[${id}]=1546_1141
	ALL_MODULE_NAME[${id}]="u-blox TOBY-L2 series"
	ALL_AT_PORT[${id}]=$(ls \
		$module_path/$dev_id:*.0/tty/ 2>/dev/null | grep tty)
	ALL_MODEM_PORT[${id}]=$(ls \
		$module_path/$dev_id:*.2/tty/ 2>/dev/null | grep tty)
}
# rndis mode
_module_1546_1146() {
	local module_path=${1}
	local id=${2}
	local module_name="${3}"
	local dev_id=${module_path//\/*\//}

	ALL_MODULE_ID[${id}]=1546_1146
	ALL_MODULE_NAME[${id}]="u-blox TOBY-L2 series"
	ALL_INTERFACE[${id}]=$(ls \
		$module_path/$dev_id:*.0/$SYS_NET/ 2>/dev/null)
	ALL_AT_PORT[${id}]=$(ls \
		$module_path/$dev_id:*.2/tty/ 2>/dev/null | grep tty)
}
# SARA-R4 series
_module_05c6_90b2() {
	local module_path=${1}
	local id=${2}
	local module_name="${3}"

	# The mux tool create two virtual ports on mux0 and mux1
	if [ -e /dev/mux0 ] && [ -e /dev/mux1 ]; then
		ALL_AT_PORT[${id}]="mux0"
		ALL_MODEM_PORT[${id}]="mux1"
	else
		ALL_AT_PORT[${id}]="ttyUSB0"
		ALL_MODEM_PORT[${id}]="ttyUSB0"
	fi

	# The GPS module is connected via UART interface in UC-2116.
	# Since the module R410M is also onboard in UC-2116, the GPS
	# detection code is put here.
	ALL_GPS_PORT[${id}]=$(ls \
		/sys/devices/platform/ocp/481aa000.serial/tty/ 2>/dev/null | grep tty)
	if [ -z "${ALL_GPS_PORT[${id}]}" ]; then
		ALL_GPS_PORT[${id}]="NotSupport"
	fi

	ALL_INTERFACE[${id}]="NotSupport"
}
_module_05c6_90b2_initialize() {
	_gsmMuxd_initial
	return
}

_module_ublox_attach_status() {
	local info=""
	local status="0"
	local cs="n/a"
	local ps="detached"

	# +CGATT: 1
	info=$(cell_at_cmd "AT+CGATT?")
	status=$(echo "${info}" | grep "^+CGATT:" | awk '{print $2}')
	if [ "${status}" == "1" ]
	then
		ps="attached"
	fi
	echo "CS: ${cs}"
	echo "PS: ${ps}"
}
_module_1546_110a_attach_status() {
	_module_ublox_attach_status
}
_module_1546_1146_attach_status() {
	_module_ublox_attach_status
}
_module_1546_1141_attach_status() {
	_module_ublox_attach_status
}
_module_05c6_90b2_attach_status() {
	_module_ublox_attach_status
}

_module_1546_110a_unlock_pin() {
	local ret=""

	ret=$(cell_at_cmd "AT+CPIN=\"$1\"" 1)
	if [ $? -ne 0 ]; then
		echo $ret
		_exit 1
	fi
}
_module_05c6_90b2_unlock_pin() {
	at_unlock_pin "$1"
	_disable_PSM
}

_module_ublox_pin_retries() {
	# +UPINCNT: 3,0,10,10
	pin_times=$(cell_at_cmd "AT+UPINCNT" | grep "^+UPINCNT" | awk '{print $2}' | cut -d ',' -f 1)
	if [ x"${pin_times}" == x"" ]; then
		echo -1
	else
		echo ${pin_times}
	fi
}
_module_1546_110a_pin_retries() {
	_module_ublox_pin_retries
}
_module_1546_1146_pin_retries() {
	_module_ublox_pin_retries
}
_module_1546_1141_pin_retries() {
	_module_ublox_pin_retries
}
_module_05c6_90b2_pin_retries() {
	_module_ublox_pin_retries
}

__module_ublox_service() {
	local info=""
	local lac=""
	local cellid=""
	local service=""

	cell_at_cmd "AT+CEREG=2" 0.5 > /dev/null 2>&1
	[ $? -ne 0 ] && return 1
	info="$(cell_at_cmd "AT+CEREG?" | grep "^+CEREG:" | awk '{print $2}')"
	lac=$(echo "${info}" | cut -d ',' -f 3 | sed -e 's/"//g')
	cellid=$(echo "${info}" | cut -d ',' -f 4 | sed -e 's/"//g')
	service=$(echo "${info}" | cut -d ',' -f 5)
	echo "${lac} ${cellid} ${service}"
}
_module_ublox_service() {
	# +CEREG: <n>,<stat>[,<lac>,<ci>[,<Act>]]
	# <lac>,<ci>,<Act> are reported only if
	#   <n>=2 and the mobile is registered on some network cell.

	# <stat> - registration status
	#   0 - not registered, the MT is not currently searching a new
	#       operator to register to
	#   1 - registered, home network
	#   2 - not registered, but the MT is currently searching a new
	#       operator to register to
	#   3 - registration denied
	#   4 - unknown
	#   5 - registered, roaming
	#   6 - registered for "SMS only", home network
	#   7 - registered for "SMS only", roaming
	#   9 - registered for "CSFB not preferred", home network
	#  10 - registered for "CSFB not preferred", roaming
	# <lac> - location area code (2G, 3G) or tracking area code (4G)
	#         in hexadecimal format (e.g. "00C3" equals 195 in decimal)
	# <ci> - cell ID in hexadecimal format.
	# <AcT>: integer type; access technology of the serving cell
	#   0 - GSM
	#   1 - GSM COMPAT
	#   2 - UTRAN
	#   3 - GSM w/EDGE
	#   4 - UTRAN w/HSDPA
	#   5 - UTRAN w/HSUPA
	#   6 - UTRAN w/HSDPA and HSUPA
	#   7 - E-UTRAN
	# +CEREG: 2,1,"2817","0107DDBB",2
	local info=""
	local _service=""
	local service=""
	local lac=""
	local cellid=""

	info=($(__module_ublox_service))
	if [ -z "${info}" ]; then
		return 1
	else
		lac=${info[0]}
		cellid=${info[1]}
		_service=${info[2]}
	fi

	if [ "${_service}" = "0" ] || [ "${_service}" = "1" ] || \
		[ "${_service}" = "3" ]; then
		service="GSM"
	elif [ "${_service}" = "2" ]; then
		service="UMTS"
	elif [ "${_service}" = "4" ]; then
		service="HSDPA"
	elif [ "${_service}" = "5" ]; then
		service="HSUPA"
	elif [ "${_service}" = "6" ]; then
		service="HSPA"
	elif [ "${_service}" = "7" ]; then
		service="LTE"
	else
		echo "Unknown service: ${_service}"
		return 1
	fi

	echo "Service: ${service}"
	echo "LAC: ${lac}"
	echo "CellID: ${cellid}"
}
_module_1546_110a_service() {
	_module_ublox_service
}
_module_1546_1146_service() {
	_module_ublox_service
}
_module_1546_1141_service() {
	_module_ublox_service
}
_module_05c6_90b2_service() {
	# <AcT>: integer type; access technology of the serving cell
	#   7 - Cat M1
	#   9 - Cat NB1
	local info=""
	local lac=""
	local cellid=""
	local service=""
	local _service=""

	info=($(__module_ublox_service))
	if [ -z "${info}" ]; then
		return 1
	else
		lac=${info[0]}
		cellid=${info[1]}
		_service=${info[2]}
	fi

	if [ "${_service}" = "7" ]; then
		service="CAT-M1"
	elif [ "${_service}" = "9" ]; then
		service="CAT-NB1"
	else
		echo "Unknown service: ${_service}"
		return 1
	fi
	echo "Service: ${service}"
	echo "LAC: ${lac}"
	echo "CellID: ${cellid}"
}

_module_1546_110a_gps_on() {
	if [ x"${GPS_PORT}" == x"NotSupport" ]; then
		>&2 echo "Error: Operation not supported."
	else
		cell_at_cmd 'AT+UGPS=1,0,1' || return $?
	fi
}

_module_1546_110a_gps_off() {
	if [ x"${GPS_PORT}" == x"NotSupport" ]; then
		>&2 echo "Error: Operation not supported."
	else
		cell_at_cmd 'AT+UGPS=0' || return $?
	fi
}

_module_ublox_iccid() {
	local iccid=$(cell_at_cmd 'AT+CCID' | grep "+CCID:" | \
		awk '{print $2}' )
	echo ICC-ID: $iccid
}
_module_1546_110a_iccid() {
	_module_ublox_iccid
}
_module_1546_1146_iccid() {
	_module_ublox_iccid
}
_module_1546_1141_iccid() {
	_module_ublox_iccid
}
_module_05c6_90b2_iccid() {
	_module_ublox_iccid
}

_module_ublox_module_ids() {
	local info="$(cell_at_cmd 'AT+CGSN')" || return $?
	local imei=$(echo "${info}" | awk '{ if(NR==2) print $0}')

	echo IMEI: $imei
}
_module_1546_110a_module_ids() {
	_module_ublox_module_ids
}
_module_1546_1146_module_ids() {
	_module_ublox_module_ids
}
_module_1546_1141_module_ids() {
	_module_ublox_module_ids
}
_module_05c6_90b2_module_ids() {
	_module_ublox_module_ids
}

_module_1546_1146_set_apn() {
	_exec_op_rtn set_profile 1 "${APN}" "IP"
}
_module_05c6_90b2_set_apn() {
	_exec_op_rtn set_profile 1 "${APN}" "IP"
}

_module_1546_1146_set_profile() {
	local id="$1"
	local apn="$2"
	local type="${3:-IP}"


	if [ $# -lt 1 ]; then
		_cell_usage_cmd _cell_usage_set_profile
		_exit 4
	fi

	[ -z "${apn}" ] && apn="\"\""
		_exec_op_rtn set_flight_mode 1 && \
		at_set_profile "${id}" "${apn}" "${type}" && \
		cell_at_cmd "AT+UCGDFLT=1,\"${type}\",\"${apn}\"" 2 \
			> /dev/null 2>&1 && \
		_exec_op_rtn set_flight_mode 0 &&
		_exit 0
	_exit 1
}
_module_05c6_90b2_set_profile() {
	local id="$1"
	local apn="$2"
	local type="${3:-IP}"

	if [ $# -lt 1 ]; then
		_cell_usage_cmd _cell_usage_set_profile
		_exit 4
	fi

	[ -z "${apn}" ] && apn='\"\"'

	cell_at_cmd "AT+COPS=2" > /dev/null

	at_set_profile "${id}" "${apn}" "${type}"

	__apn=$(at_get_profiles | cut -d ',' -f 2)

	if [ ! x"${__apn}" == x"${apn}" ]; then
		echo Failed to set APN=$apn
	else
		_update_profile "APN" "$__apn"
	fi

	cell_at_cmd "AT+COPS=0" > /dev/null

	_exit 0
}

_module_1546_1146_stop_network() {
	_clear_state

	# release IP by dhclient -r
	[ x"${QMI_NODE}" != x"" ] && cell_dhclient_kill "${QMI_NODE}"
	cell_at_cmd "AT+CGACT=0" 3 | \
		grep -q "OK" && return 0
}

__module_1546_1146_start_network() {
	local auth_arg=""
	local auth_idx=0
	local service=""
	local cid=4

	# initialize the authorization arg.
	if [ x"$Auth" != x"" ]; then
		if [ x"$Auth" == x"NONE" ]; then
			auth_idx=0
		elif [ x"$Auth" == x"PAP" ]; then
			auth_idx=1
		elif [ x"$Auth" == x"CHAP" ]; then
			auth_idx=2
		elif [ x"$Auth" == x"AUTO" ]; then
			auth_idx=3
		else
			return 1
		fi

		auth_arg="$auth_idx"
		if [ x"$Username" != x"" ]; then
			auth_arg="$auth_arg,$Username"
		fi
		if [ x"$Password" != x"" ]; then
			auth_arg="$auth_arg,$Password"
		fi
	fi

	service=$(_exec_op_rtn service | grep "Service:" | \
		cut -d ' ' -f 2- | awk '{print tolower($0)}')
	# [ x"${service}" = x"lte" ] && cid=4 || cid=1
	# LTE already connected after attached
	[ x"${service}" = x"lte" ] && return 0 || cid=1

	if [ ! -z "$auth_arg" ]; then
		cell_at_cmd "AT+UAUTHREQ=${cid},${auth_arg}" 1 || return 1
	fi

	cell_at_cmd "AT+CGACT=${cid},1" 5 | \
		grep -q "OK" && return 0
	return 1
}
_module_1546_1146_start_network() {
	local card_status=""
	local ignore_dns_gw=0
	local pin_status
	local cid=4


	_start_network_init $@

	echo "Status: connecting" > "${STATUS_FILE}"

	ip link set ${QMI_NODE} up

	__module_1546_1146_start_network
	if [ $? -ne 0 ]; then
		_module_1546_1146_stop_network
		_exit 1
	fi

	cid=$(cell_at_cmd 'AT+CGACT?' | grep "^+CGACT: .,1$" | sed 's/+CGACT: \([1,4]\),1/\1/')
	[ $? -ne 0 ] && _exit 1

	# Use bridge mode instead of router mode
	export new_ip_address="$(cell_at_cmd 'AT+CGPADDR='${cid}|grep -i 'CGPADDR:'|cut -d ',' -f 2|tr -d '"')"
	export new_routers="$(cell_at_cmd 'AT+UIPADDR='${cid}|grep -i 'UIPADDR:'|cut -d ',' -f 3|tr -d '"')"
	export new_subnet_mask="$(cell_at_cmd 'AT+UIPADDR='${cid}|grep -i 'UIPADDR:'|cut -d ',' -f 4|tr -d '"')"
	export new_domain_name_servers="$(cell_at_cmd 'AT+CGCONTRDP='${cid}|grep -i 'CGCONTRDP:'|cut -d ',' -f 6,7|tr -d '"'|tr ',' ' ')"
	export interface="${QMI_NODE}"
	export reason='RENEW'
	export SLOT=1
	export PKG='moxa-cellular-utils'
	export IGNORE_DNS_GW=${ignore_dns_gw}
	# Use dhclient mechanism instead of run ifconfig/route, consistency the design
	dhclient-script

	_exit 0
}
__module_05c6_90b2_start_network() {
	# _attach_sta = 8 : CAT-M1
	# _attach_sta = 9 : CAT-NB1

	local retry=300

	for para in $@
	do
		if echo "$para" | grep 'APN=' > /dev/null; then
			_apn=$(echo $para | cut -d '=' -f 2)
		fi
	done

	# Detach
	cell_at_cmd 'AT+COPS=2' 5 > /dev/null 2>&1
	sleep 0.5
	[ -n "$_apn" ] && \
		cell_at_cmd "AT+CGDCONT=1,\"IP\",\"$_apn\"" > /dev/null 2>&1
	sleep 0.5
	cell_at_cmd 'AT+COPS=0' 5 > /dev/null 2>&1

	while ((retry))
	do
		local _attach_sta="$(cell_at_cmd 'AT+COPS?' 5 | \
					grep -i '^+COPS' | \
					cut -d , -f 4)"
		if [ x"$_attach_sta" == x"7" ] || [ x"$_attach_sta" == x"9" ]; then
			return 0
		fi
		((retry--))
		sleep 1
	done
	return 1
}
_module_05c6_90b2_start_network() {
	# Although SARA-R4 provides QMI ports, the uBlox suggests to dial-up
	# via ppp

	# Before go ahead to invoke the wvdial, reattaching
	echo "Will take some time to reattach. Wait ..."
	__module_05c6_90b2_start_network $@
	if [ x"$?" == x"1" ]; then
		echo "Timeout! Not able to attach."
		_exit 0
	fi
	at_start_network $@
}

_module_1546_110a_wvdial_template_file() {
	local service=$(_module_ublox_service | grep "^Service:")

	local LTE=$(echo "$service" | grep "LTE")
	if [ -n "$LTE" ]; then
		echo "${CONF_DIR}/wvdial/ubloxR280_4G.conf.template"
	else
		echo "${CONF_DIR}/wvdial/wvdial.conf.template"
	fi
}

_module_1546_1141_wvdial_template_file() {
	local service=$(_module_1546_1141_service | grep "^Service:")

	local LTE=$(echo "$service" | grep "LTE")
	if [ -n "$LTE" ]; then
		Phone=*99***4#
		echo "${CONF_DIR}/wvdial/ublox-toby-l2.conf.template"
	else
		Phone=*99***1#
		echo "${CONF_DIR}/wvdial/wvdial.conf.template"
	fi
}

_module_05c6_90b2_wvdial_template_file() {
	echo "${CONF_DIR}/wvdial/ublox-R410M-02B.conf.template"
}

# Check Carrier
_module_1546_1146_check_carrier () {
	cell_at_cmd "AT" > /dev/null 2>&1
	local carrier_idx="$(cell_at_cmd 'AT+UMNOCONF?' |\
		 grep 'UMNOCONF' |\
		 awk '{print $2}' |\
		 cut -d ',' -f 1)"
	local mode=$(echo ${carrier_idx})
	if [ x"$mode" == x"1" ]; then
		echo "Auto"
	elif [ x"$mode" == x"2" ]; then
		echo "ATT"
	elif [ x"$mode" == x"3" ]; then
		echo "Verizon"
	else
		echo "Unknown"
	fi
}
_module_1546_1141_check_carrier () {
	_module_1546_1146_check_carrier $@
}
_module_1546_1143_check_carrier () {
	_module_1546_1146_check_carrier $@
}
__module_05c6_90b2_check_carrier () {
	cell_at_cmd "AT" > /dev/null 2>&1
	local carrier_idx="$(cell_at_cmd 'AT+UMNOPROF?' |\
		 grep '^+UMNOPROF' |\
		 awk '{print $2}' |\
		 cut -d ',' -f 1)"
	local mode=$(echo ${carrier_idx})
	if [ "$mode" = "0" ]; then
		echo "SW default"
	elif [ "$mode" = "1" ]; then
		echo "Auto"
	elif [ "$mode" = "2" ]; then
		echo "ATT"
	elif [ "$mode" = "3" ]; then
		echo "Verizon"
	elif [ "$mode" = "4" ]; then
		echo "Telstra"
	elif [ "$mode" = "5" ]; then
		echo "TMO"
	elif [ "$mode" = "6" ]; then
		echo "China Telecom"
	elif [ "$mode" = "8" ]; then
		echo "Sprint"
	elif [ "$mode" = "19" ]; then
		echo "Vodafone"
	elif [ "$mode" = "21" ]; then
		echo "TELUS"
	elif [ "$mode" = "31" ]; then
		echo "DT"
	elif [ "$mode" = "100" ]; then
		echo "Standard Europe"
	else
		echo "Unknown"
	fi
}
_module_05c6_90b2_check_carrier () {
	cell_at_cmd "AT" > /dev/null 2>&1
	fw="$(cell_at_cmd "ATI" | grep '^Revision' | sed 's/^Revision: \(.*\)/\1/g')"
	carrier_name="$(__module_05c6_90b2_check_carrier)"
	carriers="SW|Auto|ATT|Verizon|Telstra|TMO|China Telecom|\
Sprint|Vodafone|TELUS|DT|Standard Europe"

	echo "----------Carrier Info----------"
	echo "firmware=$fw"
	echo "carrier name=$carrier_name"
	echo "available carriers="${carriers}
	echo -e "--------------------------------"
}


# Carrier switch
_module_1546_1146_switch_carrier () {
	#check the module
	cell_at_cmd "AT" > /dev/null 2>&1
	local model_name=$(cell_at_cmd "ATI" | grep 'TOBY' | cut -d '-' -f 2)
	local need_reboot=0
	case "${model_name}" in
		L201)
			cell_at_cmd "AT+UMNOCONF?" > /dev/null
			# Only support AUTO-SIM, ATT and Verizon
			if [ x"$1" = x"Auto" ]; then
				cell_at_cmd "AT+UMNOCONF=1" > /dev/null
			elif [ x"$1" = x"ATT" ]; then
				cell_at_cmd "AT+UMNOCONF=2" > /dev/null
				need_reboot=1
			elif [ x"$1" = x"Verizon" ]; then
				cell_at_cmd "AT+UMNOCONF=3" > /dev/null
				need_reboot=1
			else
				echo "Error: Operation not supported."
				echo -e "Usage: "
				echo -e "       switch_carrier <Auto|ATT|Verizon>"
				_exit 3
			fi
			if [ "$?" -ne "0" ]; then
				echo "Switch Failed ..."
			else
				echo "Switch to $1"
				echo "Waiting for the module silent reboot"
				if [ x"$need_reboot" = x"1" ]; then
					cell_at_cmd "AT+CFUN=16"
				fi
				sleep 10
			fi
			;;
		*)
			# L280 and L210  are not supporting the carrier switch
			echo "Error: Operation not supported."
			_exit 3
			;;
	esac
}
_module_1546_1141_switch_carrier () {
	_module_1546_1146_switch_carrier $@
}
_module_1546_1143_switch_carrier () {
	_module_1546_1146_switch_carrier $@
}

# Carrier switch
_module_05c6_90b2_switch_carrier () {
	#check the module
	cell_at_cmd "AT" > /dev/null 2>&1
	local model_name=$(cell_at_cmd "ATI" | grep 'Model:' | cut -d ' ' -f 2)
	local need_reboot=0
	local profile_id=""
	local response=""
	local retry=0
	case "${model_name}" in
		SARA-R410M-02B)
			cell_at_cmd "AT+UMNOPROF?" > /dev/null
			# Support AUTO-SIM, ATT, Verizon, Telstra,
			# TMO, China Telecom, Sprint, Vodafone, TELUS, DT
			# and Standard Europe
			if [ "$1" = "SW" ]; then
				profile_id="0"
			elif [ "$1" = "Auto" ]; then
				profile_id="1"
			elif [ "$1" = "ATT" ]; then
				profile_id="2"
			elif [ "$1" = "Verizon" ]; then
				profile_id="3"
			elif [ "$1" = "Telstra" ]; then
				profile_id="4"
			elif [ "$1" = "TMO" ]; then
				profile_id="5"
			elif [ "$1" = "China Telecom" ]; then
				profile_id="6"
			elif [ "$1" = "Sprint" ]; then
				profile_id="8"
			elif [ "$1" = "Vodafone" ]; then
				profile_id="19"
			elif [ "$1" = "TELUS" ]; then
				profile_id="21"
			elif [ "$1" = "DT" ]; then
				profile_id="31"
			elif [ "$1" = "Standard Europe" ]; then
				profile_id="100"
			else
				echo -e "Usage: "
				echo -e "\tswitch_carrier \"<SW|Auto|ATT|Verizon|Telstra\
|TMO|China Telecom|Sprint|Vodafone\
|TELUS|DT|Standard Europe>\""
				_exit 3
			fi
			response=$(cell_at_cmd "AT+UMNOPROF=${profile_id}" 10)
			if echo "${response}" | grep -q '^OK'; then
				echo "Switch to ${1} ..."
			else
				echo "Switch Failed ... Please try again ..."
				_exit 3
			fi
			echo "Waiting for the module silent reboot."
			response=$(cell_at_cmd "AT+CFUN=15,1" 10)
			if echo "${response}" | grep -q '^OK'; then
				# The module is under reseting, check whether the AT port comes back.
				retry=15
				while ((retry--)); do
					if mxat -d /dev/ttyUSB0 -c 'AT' -t 5 | grep -q '^OK'; then
						_module_05c6_90b2_initialize
						_disable_PSM
						return
					else
						sleep 1
					fi
				done
				echo "Module does not come back, please perform power_cycle."
				_exit 3
			else
				echo "Reboot Failed ... Please try again ..."
				_exit 3
			fi
			;;
		*)
			echo "Error: Operation not supported."
			_exit 3
			;;
	esac
}

_gsmMuxd_termination () {
	local prog_name="gsmMuxd"
	local gsm_pid="$(pgrep ${prog_name})"
	local retry=10

	if [ -z "${gsm_pid}" ]; then
		return
	else
		pkill -9 ${prog_name}
	fi
	while ((retry--)); do
		if kill -0 ${gsm_pid} > /dev/null 2>&1; then
			sleep 1
		else
			break;
		fi
	done
}

_gsmMuxd_initial() {
	local port=/dev/ttyUSB0

	if ! [ -x "$(command -v gsmMuxd)" ]; then
		return
	fi

	_gsmMuxd_termination

	stty -F $port 115200
	gsmMuxd -w -p $port -s /dev/mux /dev/ptmx /dev/ptmx
	if ! (($?)); then
		echo -ne "ATE0\r\n" 2>/dev/null >/dev/mux0
	fi
}

_disable_PSM() {
	# Disable PSM mode
	# In current design, this makes the UC2114/6 sleep forever.
	# Need to use power_cycle to make it alive
	cell_at_cmd "AT+CPSMS=0" > /dev/null 2>&1
}
